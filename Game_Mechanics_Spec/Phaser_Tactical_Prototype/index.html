<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHT Tactical Combat - Phaser 3 Prototype v4 (Full Character System)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            font-family: 'Segoe UI', sans-serif;
            color: #eee;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        #top-bar {
            height: 50px;
            background: linear-gradient(180deg, #0f0f23, #1a1a2e);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-bottom: 2px solid #333;
        }
        #turn-indicator {
            font-size: 20px;
            font-weight: bold;
        }
        .team-a { color: #3498db; }
        .team-b { color: #e74c3c; }
        #game-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        #game-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #16213e;
        }
        #combat-log-panel {
            width: 320px;
            background: #0f0f23;
            border-left: 2px solid #333;
            display: flex;
            flex-direction: column;
        }
        #combat-log-header {
            padding: 10px;
            background: #1a1a2e;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #verbosity-toggle {
            font-size: 10px;
            padding: 3px 8px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #aaa;
            cursor: pointer;
        }
        #verbosity-toggle:hover { background: #444; }
        #verbosity-toggle.concise { color: #4ecdc4; border-color: #4ecdc4; }
        #combat-log {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            font-size: 11px;
            font-family: monospace;
        }
        .log-entry {
            padding: 3px 6px;
            margin: 2px 0;
            border-radius: 3px;
            border-left: 3px solid #333;
        }
        .log-attack { border-color: #e74c3c; background: rgba(231,76,60,0.1); }
        .log-damage { border-color: #f39c12; background: rgba(243,156,18,0.1); }
        .log-move { border-color: #3498db; background: rgba(52,152,219,0.1); }
        .log-system { border-color: #9b59b6; background: rgba(155,89,182,0.1); }
        .log-kill { border-color: #c0392b; background: rgba(192,57,43,0.2); font-weight: bold; }
        .log-effect { border-color: #2ecc71; background: rgba(46,204,113,0.1); }
        .log-injury { border-color: #e67e22; background: rgba(230,126,34,0.15); font-style: italic; }
        .log-ai { border-color: #9b59b6; background: rgba(155,89,182,0.15); color: #d4a5ff; }

        /* Character inspection tooltip */
        #char-tooltip {
            position: absolute;
            display: none;
            background: rgba(15, 15, 35, 0.95);
            border: 2px solid #4ecdc4;
            border-radius: 8px;
            padding: 12px;
            min-width: 280px;
            max-width: 350px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            font-size: 12px;
        }
        #char-tooltip .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }
        #char-tooltip .tooltip-name {
            font-size: 16px;
            font-weight: bold;
        }
        #char-tooltip .tooltip-origin {
            font-size: 11px;
            color: #888;
        }
        #char-tooltip .tooltip-personality {
            background: rgba(78, 205, 196, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        #char-tooltip .tooltip-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px 8px;
            margin: 8px 0;
        }
        #char-tooltip .tooltip-stat {
            text-align: center;
            background: rgba(255,255,255,0.05);
            padding: 4px;
            border-radius: 4px;
        }
        #char-tooltip .tooltip-stat-label {
            font-size: 9px;
            color: #888;
        }
        #char-tooltip .tooltip-stat-value {
            font-weight: bold;
            color: #fff;
        }
        #char-tooltip .tooltip-effects {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        #char-tooltip .tooltip-effect {
            background: rgba(231,76,60,0.3);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
        }
        #char-tooltip .tooltip-immunities {
            margin-top: 6px;
            font-size: 10px;
            color: #2ecc71;
        }

        /* BOTTOM BAR - Character Info */
        #bottom-bar {
            height: 160px;
            background: linear-gradient(0deg, #0a0a15, #0f0f23);
            border-top: 2px solid #4ecdc4;
            display: flex;
            padding: 10px 20px;
            gap: 15px;
        }
        #bottom-left {
            display: flex;
            gap: 15px;
            flex: 1;
            overflow-x: auto;
        }
        #bottom-right {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            justify-content: center;
            min-width: 120px;
        }
        #unit-cards {
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }
        .team-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .team-header {
            font-size: 12px;
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 4px;
            text-align: center;
        }
        .team-header.blue { background: rgba(52, 152, 219, 0.3); color: #3498db; }
        .team-header.red { background: rgba(231, 76, 60, 0.3); color: #e74c3c; }
        .team-units {
            display: flex;
            gap: 8px;
        }
        .team-divider {
            width: 3px;
            background: linear-gradient(180deg, #333, #4ecdc4, #333);
            margin: 0 10px;
            border-radius: 2px;
        }
        .unit-card {
            width: 130px;
            background: #1a1a2e;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #333;
            position: relative;
        }
        .unit-card:hover { border-color: #4ecdc4; transform: translateY(-2px); }
        .unit-card.selected { border-color: #ffff00; box-shadow: 0 0 15px rgba(255,255,0,0.3); }
        .unit-card.acted { opacity: 0.5; }
        .unit-card.enemy { border-color: #e74c3c; }
        .unit-card.dead { display: none; }
        .unit-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .unit-card-name {
            font-weight: bold;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 90px;
        }
        .unit-card-name.team-a { color: #3498db; }
        .unit-card-name.team-b { color: #e74c3c; }
        .unit-card-origin {
            font-size: 14px;
        }
        .unit-card-hp {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .unit-card-hp-fill {
            height: 100%;
            background: #2ecc71;
            transition: width 0.3s;
        }
        .unit-card-hp-fill.wounded { background: #f39c12; }
        .unit-card-hp-fill.critical { background: #e74c3c; }
        .unit-card-stats {
            font-size: 10px;
            color: #888;
            display: flex;
            justify-content: space-between;
        }
        .unit-card-weapon {
            font-size: 11px;
            color: #4ecdc4;
            margin-top: 3px;
        }
        .unit-card-ap {
            display: flex;
            gap: 2px;
            margin-top: 4px;
        }
        .ap-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #555;
        }
        .ap-dot.filled { background: #3498db; border-color: #2980b9; }
        .unit-card-effects {
            display: flex;
            gap: 2px;
            margin-top: 4px;
            flex-wrap: wrap;
        }
        .effect-icon {
            font-size: 12px;
            cursor: help;
        }

        /* Selected unit detail panel */
        #selected-unit-detail {
            flex: 1;
            background: #1a1a2e;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            gap: 20px;
            align-items: center;
            min-width: 400px;
        }
        #selected-unit-detail.hidden { display: none; }
        .detail-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .detail-origin-emoji {
            font-size: 32px;
        }
        .detail-name {
            font-size: 22px;
            font-weight: bold;
        }
        .detail-subtitle {
            font-size: 11px;
            color: #888;
        }
        .detail-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px 15px;
            font-size: 13px;
        }
        .detail-stat-label { color: #888; }
        .detail-stat-value { color: #fff; font-weight: bold; }
        .detail-hp-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }
        .detail-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s;
        }
        .detail-ap-bar {
            display: flex;
            gap: 4px;
        }
        .detail-ap-pip {
            width: 16px;
            height: 16px;
            background: #333;
            border-radius: 3px;
            border: 2px solid #555;
        }
        .detail-ap-pip.filled { background: #3498db; border-color: #2980b9; }
        .detail-effects {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }
        .detail-effect-badge {
            background: rgba(231,76,60,0.3);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #end-turn-btn {
            padding: 15px 30px;
            background: linear-gradient(180deg, #e74c3c, #c0392b);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        #end-turn-btn:hover { transform: scale(1.05); }
        #end-turn-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        #ai-vs-ai-btn {
            padding: 15px 20px;
            background: linear-gradient(180deg, #9b59b6, #8e44ad);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        #ai-vs-ai-btn:hover { transform: scale(1.05); }
        #ai-vs-ai-btn.active { background: linear-gradient(180deg, #27ae60, #2ecc71); }

        #careers-btn {
            padding: 15px 20px;
            background: linear-gradient(180deg, #f39c12, #d68910);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        #careers-btn:hover { transform: scale(1.05); }

        #instructions {
            font-size: 12px;
            color: #666;
        }

        /* Hover info display */
        #hover-info {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 35, 0.9);
            border: 1px solid #4ecdc4;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            display: none;
            z-index: 100;
        }
        #hover-info.move-mode {
            border-color: #3498db;
        }
        #hover-info.attack-mode {
            border-color: #e74c3c;
        }
    </style>
</head>
<body>
    <div id="top-bar">
        <div id="turn-indicator">Turn 1 - <span class="team-a">üîµ BLUE TEAM</span></div>
        <div id="instructions">üñ±Ô∏è Click unit to select | üèÉ Click tile to move | ‚öîÔ∏è Click enemy to attack</div>
    </div>

    <div id="game-area">
        <div id="game-container"></div>
        <div id="combat-log-panel">
            <div id="combat-log-header">
                <span>üìú Combat Log</span>
                <button id="verbosity-toggle" onclick="toggleVerbosity()">üìù VERBOSE</button>
            </div>
            <div id="combat-log"></div>
        </div>
    </div>

    <div id="bottom-bar">
        <div id="bottom-left">
            <div id="unit-cards"></div>
            <div id="selected-unit-detail" class="hidden">
                <div>
                    <div class="detail-header">
                        <span class="detail-origin-emoji" id="detail-origin-emoji">üßë</span>
                        <div>
                            <div class="detail-name" id="detail-name">-</div>
                            <div class="detail-subtitle" id="detail-subtitle">-</div>
                        </div>
                    </div>
                    <div class="detail-hp-bar"><div class="detail-hp-fill" id="detail-hp-fill"></div></div>
                    <div style="font-size: 12px; margin-top: 3px;"><span id="detail-hp-text">100/100</span> ‚ù§Ô∏è</div>
                    <div class="detail-effects" id="detail-effects"></div>
                </div>
                <div class="detail-stats">
                    <span class="detail-stat-label">üî´ Weapon:</span><span class="detail-stat-value" id="detail-weapon">-</span>
                    <span class="detail-stat-label">üí• Damage:</span><span class="detail-stat-value" id="detail-damage">-</span>
                    <span class="detail-stat-label">üìè Range:</span><span class="detail-stat-value" id="detail-range">-</span>
                    <span class="detail-stat-label">üõ°Ô∏è Armor:</span><span class="detail-stat-value" id="detail-armor">-</span>
                    <span class="detail-stat-label">üí™ STR:</span><span class="detail-stat-value" id="detail-str">-</span>
                    <span class="detail-stat-label">üèÉ AGL:</span><span class="detail-stat-value" id="detail-agl">-</span>
                </div>
                <div>
                    <div style="font-size: 12px; color: #888; margin-bottom: 5px;">‚ö° Action Points</div>
                    <div class="detail-ap-bar" id="detail-ap-bar"></div>
                </div>
            </div>
        </div>
        <div id="bottom-right">
            <button id="end-turn-btn">‚è≠Ô∏è End Turn</button>
            <button id="team-select-btn" title="Switch which team you control">üîµ Playing: BLUE</button>
            <button id="ai-vs-ai-btn">ü§ñ AI vs AI</button>
            <button id="roster-btn" title="Manage team rosters">üë• Roster</button>
            <button id="careers-btn">üìä Careers</button>
        </div>
    </div>

    <div id="char-tooltip"></div>
    <div id="hover-info"></div>

    <!-- Roster Management Modal -->
    <div id="roster-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 1000; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 20px auto; padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #f39c12; margin: 0;">üë• ROSTER MANAGEMENT</h2>
                <div>
                    <button onclick="openCharacterCreator()" style="padding: 10px 20px; background: #27ae60; border: none; color: white; border-radius: 5px; cursor: pointer; margin-right: 10px;">‚ûï Create New Character</button>
                    <button onclick="startBattleWithRoster()" style="padding: 10px 20px; background: #e74c3c; border: none; color: white; border-radius: 5px; cursor: pointer; margin-right: 10px;">‚öîÔ∏è START BATTLE</button>
                    <button onclick="closeRosterModal()" style="padding: 10px 20px; background: #7f8c8d; border: none; color: white; border-radius: 5px; cursor: pointer;">‚úñÔ∏è Close</button>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 100px 1fr; gap: 20px;">
                <!-- Blue Team -->
                <div style="background: rgba(52, 152, 219, 0.2); border: 2px solid #3498db; border-radius: 10px; padding: 20px;">
                    <h3 style="color: #3498db; margin: 0 0 15px 0;">üîµ BLUE TEAM</h3>
                    <div id="blue-team-roster" style="min-height: 200px;"></div>
                </div>

                <!-- Transfer Buttons -->
                <div style="display: flex; flex-direction: column; justify-content: center; gap: 10px;">
                    <button onclick="moveToRed()" style="padding: 15px; background: #e74c3c; border: none; color: white; border-radius: 5px; cursor: pointer; font-size: 18px;">‚Üí</button>
                    <button onclick="moveToBlue()" style="padding: 15px; background: #3498db; border: none; color: white; border-radius: 5px; cursor: pointer; font-size: 18px;">‚Üê</button>
                </div>

                <!-- Red Team -->
                <div style="background: rgba(231, 76, 60, 0.2); border: 2px solid #e74c3c; border-radius: 10px; padding: 20px;">
                    <h3 style="color: #e74c3c; margin: 0 0 15px 0;">üî¥ RED TEAM</h3>
                    <div id="red-team-roster" style="min-height: 200px;"></div>
                </div>
            </div>

            <!-- Available Characters -->
            <div style="margin-top: 20px; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 20px;">
                <h3 style="color: #f39c12; margin: 0 0 15px 0;">üì¶ AVAILABLE CHARACTERS (Click to select, then assign to team)</h3>
                <div id="available-roster" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;"></div>
            </div>
        </div>
    </div>

    <script>
    // ============================================================
    // SHT TACTICAL COMBAT - PHASER 3 PROTOTYPE v4
    // Full Character System with:
    // - 20 Personality Types with AI combat preferences
    // - 9 Origin Types with damage immunities
    // - Rich combat feedback with weapon-type verbs
    // - Status effects with emoji icons
    // - Movement path vs attack indicator on hover
    // - Injury system integration
    // ============================================================

    // ============ ORIGIN TYPES ============
    // Based on Origin_Types.csv - 9 categories from LSW classification
    // Now includes POWERS - what each origin can DO
    const ORIGINS = {
        skilled_human: {
            id: 'skilled_human',
            name: 'Skilled Human',
            emoji: 'üßë',
            description: 'Peak human training, no powers',
            powers: ['üéØ +10% Accuracy', 'üõ°Ô∏è +5% Evasion', 'üß† Tactical Awareness'],
            combatBonus: { accuracy: 10, evasion: 5 },
            specialAction: 'AIMED SHOT: Spend extra AP for +20% crit chance',
            bleeds: true,
            burns: true,
            freezes: true,
            stuns: true,
            empVulnerable: false,
            poisonable: true,
            deathVisual: 'collapse',
            bloodColor: 0xcc0000
        },
        altered_human: {
            id: 'altered_human',
            name: 'Altered Human',
            emoji: 'üß¨',
            description: 'Enhanced through science or accident',
            powers: ['üí™ +20% STR damage', 'üèÉ +1 Movement', '‚ö° Enhanced Reflexes'],
            combatBonus: { strDamage: 20, movement: 1 },
            specialAction: 'POWER SURGE: Double damage on next attack (1/battle)',
            bleeds: true,
            burns: true,
            freezes: true,
            stuns: true,
            empVulnerable: false,
            poisonable: true,
            deathVisual: 'collapse',
            bloodColor: 0xcc0000
        },
        mutant: {
            id: 'mutant',
            name: 'Mutant',
            emoji: 'üß™',
            description: 'Born with genetic powers',
            powers: ['üîÆ Random Power Mutation', 'üß¨ Adaptive Resistance', '‚ö° Unique Ability'],
            combatBonus: { randomBonus: true },
            specialAction: 'MUTATE: Gain random buff (+damage, +armor, or +healing)',
            bleeds: true,
            burns: true,
            freezes: true,
            stuns: true,
            empVulnerable: false,
            poisonable: true,
            deathVisual: 'collapse',
            bloodColor: 0xcc00cc // Purple blood
        },
        tech_enhanced: {
            id: 'tech_enhanced',
            name: 'Tech Enhanced',
            emoji: 'ü¶æ',
            description: 'Cybernetics or powered armor',
            powers: ['üîß Self-Repair 5 HP/turn', 'üì° Enhanced Sensors', '‚ö° Power Boost'],
            combatBonus: { regen: 5, sensorRange: 2 },
            specialAction: 'OVERCLOCK: +3 AP this turn, take 10 damage',
            bleeds: 'partial', // Only organic parts
            burns: true,
            freezes: true,
            stuns: true,
            empVulnerable: true,
            poisonable: 'partial',
            deathVisual: 'sparks',
            bloodColor: 0x884400
        },
        mystic: {
            id: 'mystic',
            name: 'Mystic',
            emoji: 'üîÆ',
            description: 'Magic-based powers',
            powers: ['‚ú® Energy Attacks +30%', 'üõ°Ô∏è Magic Shield', 'üëÅÔ∏è See Invisible'],
            combatBonus: { energyDamage: 30, magicShield: true },
            specialAction: 'ARCANE BLAST: AoE energy attack hitting all adjacent enemies',
            bleeds: true,
            burns: true,
            freezes: true,
            stuns: true,
            empVulnerable: false,
            poisonable: true,
            deathVisual: 'fade',
            bloodColor: 0x8800ff
        },
        alien: {
            id: 'alien',
            name: 'Alien',
            emoji: 'üëΩ',
            description: 'Extraterrestrial origin',
            powers: ['üëÅÔ∏è Alien Senses (+2 vision)', 'üß¨ Bizarre Physiology', '‚ö° Unknown Tech'],
            combatBonus: { visionRange: 2, unpredictable: true },
            specialAction: 'XENOBIOLOGY: 50% resist random status effects',
            bleeds: 'ichor', // Green/blue alien blood
            burns: 'varies',
            freezes: 'varies',
            stuns: true,
            empVulnerable: false,
            poisonable: 'varies',
            deathVisual: 'dissolve',
            bloodColor: 0x00ff88
        },
        cosmic: {
            id: 'cosmic',
            name: 'Cosmic',
            emoji: '‚ú®',
            description: 'Universal/dimensional powers',
            powers: ['üåü Cosmic Energy +50%', 'üõ°Ô∏è Immune to Status', '‚ú® Reality Warp'],
            combatBonus: { cosmicDamage: 50, statusImmune: true },
            specialAction: 'COSMIC SURGE: Ignore all armor for 1 attack',
            bleeds: false,
            burns: false,
            freezes: false,
            stuns: 'resistant',
            empVulnerable: false,
            poisonable: false,
            deathVisual: 'explode_light',
            bloodColor: 0xffffff
        },
        divine: {
            id: 'divine',
            name: 'Divine',
            emoji: 'üëº',
            description: 'Godly or mythological',
            powers: ['‚òÄÔ∏è Holy Damage +25%', 'üíö Heal 10 HP/turn', 'üõ°Ô∏è Divine Protection'],
            combatBonus: { holyDamage: 25, regen: 10 },
            specialAction: 'SMITE: Deal double damage to evil-aligned targets',
            bleeds: 'ichor', // Golden ichor
            burns: false,
            freezes: false,
            stuns: 'resistant',
            empVulnerable: false,
            poisonable: false,
            deathVisual: 'ascend',
            bloodColor: 0xffcc00
        },
        construct: {
            id: 'construct',
            name: 'Construct',
            emoji: 'ü§ñ',
            description: 'Robot, golem, or created being',
            powers: ['üõ°Ô∏è +50% HP', '‚ö° No Fatigue', 'üîß Self-Repair'],
            combatBonus: { hpBonus: 50, noFatigue: true },
            specialAction: 'SHUTDOWN PROTOCOL: Sacrifice to deal 50 AoE damage',
            bleeds: false,
            burns: false,
            freezes: 'resistant',
            stuns: false,
            empVulnerable: true,
            poisonable: false,
            deathVisual: 'shutdown',
            bloodColor: 0x444444 // Oil/hydraulic fluid
        }
    };

    // ============ PERSONALITY TYPES ============
    // Based on Combat Compendium REAL - PERSONALITY TARGET SELECTION.csv
    // Target preferences: 1=Most HP, 2=Least HP, 3=Major Threat, 4=Minor Threat, 5=Random
    const PERSONALITIES = {
        aggressive: { id: 'aggressive', name: 'Aggressive', emoji: 'üò†', targetPref: 3, description: 'Attacks biggest threats first', aiStyle: 'rush' },
        cautious: { id: 'cautious', name: 'Cautious', emoji: 'üò∞', targetPref: 4, description: 'Picks off weaker targets', aiStyle: 'defensive' },
        bloodthirsty: { id: 'bloodthirsty', name: 'Bloodthirsty', emoji: 'ü©∏', targetPref: 2, description: 'Finishes wounded enemies', aiStyle: 'rush' },
        tactical: { id: 'tactical', name: 'Tactical', emoji: 'üéØ', targetPref: 3, description: 'Eliminates threats systematically', aiStyle: 'balanced' },
        protective: { id: 'protective', name: 'Protective', emoji: 'üõ°Ô∏è', targetPref: 3, description: 'Neutralizes dangers to team', aiStyle: 'defensive' },
        berserker: { id: 'berserker', name: 'Berserker', emoji: 'üî•', targetPref: 1, description: 'Charges strongest foe', aiStyle: 'rush' },
        sniper: { id: 'sniper', name: 'Sniper', emoji: 'üî≠', targetPref: 2, description: 'Picks off the wounded', aiStyle: 'ranged' },
        opportunist: { id: 'opportunist', name: 'Opportunist', emoji: 'ü¶ä', targetPref: 2, description: 'Exploits weakness', aiStyle: 'balanced' },
        methodical: { id: 'methodical', name: 'Methodical', emoji: 'üìã', targetPref: 4, description: 'Systematic elimination', aiStyle: 'balanced' },
        reckless: { id: 'reckless', name: 'Reckless', emoji: 'üíÄ', targetPref: 5, description: 'Unpredictable targeting', aiStyle: 'rush' },
        cunning: { id: 'cunning', name: 'Cunning', emoji: 'ü¶é', targetPref: 4, description: 'Avoids strong enemies', aiStyle: 'defensive' },
        heroic: { id: 'heroic', name: 'Heroic', emoji: '‚≠ê', targetPref: 1, description: 'Takes on the strongest', aiStyle: 'balanced' },
        cowardly: { id: 'cowardly', name: 'Cowardly', emoji: 'üò®', targetPref: 4, description: 'Only attacks weak targets', aiStyle: 'defensive' },
        vengeful: { id: 'vengeful', name: 'Vengeful', emoji: '‚ö°', targetPref: 3, description: 'Targets whoever hurt allies', aiStyle: 'rush' },
        cold: { id: 'cold', name: 'Cold', emoji: 'üßä', targetPref: 3, description: 'Emotionless efficiency', aiStyle: 'balanced' },
        sadistic: { id: 'sadistic', name: 'Sadistic', emoji: 'üòà', targetPref: 2, description: 'Enjoys finishing wounded', aiStyle: 'rush' },
        honorable: { id: 'honorable', name: 'Honorable', emoji: '‚öîÔ∏è', targetPref: 1, description: 'Faces strongest opponent', aiStyle: 'balanced' },
        paranoid: { id: 'paranoid', name: 'Paranoid', emoji: 'üëÅÔ∏è', targetPref: 3, description: 'Eliminates biggest threats', aiStyle: 'defensive' },
        calculating: { id: 'calculating', name: 'Calculating', emoji: 'üß†', targetPref: 3, description: 'Optimal target selection', aiStyle: 'balanced' },
        instinctive: { id: 'instinctive', name: 'Instinctive', emoji: 'üê∫', targetPref: 5, description: 'Gut feeling targeting', aiStyle: 'rush' }
    };

    // ============ THREAT LEVELS ============
    const THREAT_LEVELS = {
        alpha: { name: 'Alpha', emoji: '‚ö™', color: '#888888', description: 'Non-threat baseline' },
        level1: { name: 'Level 1', emoji: 'üü¢', color: '#2ecc71', description: 'Minor threat' },
        level2: { name: 'Level 2', emoji: 'üü°', color: '#f1c40f', description: 'Moderate threat' },
        level3: { name: 'Level 3', emoji: 'üü†', color: '#e67e22', description: 'Significant threat' },
        level4: { name: 'Level 4', emoji: 'üî¥', color: '#e74c3c', description: 'Major threat' },
        level5: { name: 'Level 5', emoji: 'üü£', color: '#9b59b6', description: 'Extinction-level threat' }
    };

    // ============ STATUS EFFECTS ============
    const STATUS_EFFECTS = {
        bleeding: { id: 'bleeding', name: 'Bleeding', emoji: 'ü©∏', damagePerTurn: 3, duration: 3, stackable: true },
        burning: { id: 'burning', name: 'Burning', emoji: 'üî•', damagePerTurn: 5, duration: 2, stackable: false },
        frozen: { id: 'frozen', name: 'Frozen', emoji: 'üßä', apPenalty: 2, duration: 1, stackable: false },
        stunned: { id: 'stunned', name: 'Stunned', emoji: 'üí´', skipTurn: true, duration: 1, stackable: false },
        poisoned: { id: 'poisoned', name: 'Poisoned', emoji: '‚ò†Ô∏è', damagePerTurn: 2, duration: 4, stackable: true },
        emp: { id: 'emp', name: 'EMP', emoji: '‚ö°', apPenalty: 3, duration: 2, stackable: false },
        suppressed: { id: 'suppressed', name: 'Suppressed', emoji: 'üìç', accuracyPenalty: 20, duration: 1, stackable: false },
        inspired: { id: 'inspired', name: 'Inspired', emoji: '‚ú®', accuracyBonus: 10, duration: 2, stackable: false },
        shielded: { id: 'shielded', name: 'Shielded', emoji: 'üõ°Ô∏è', drBonus: 5, duration: 2, stackable: false }
    };

    // ============ DAMAGE VERBS BY WEAPON TYPE ============
    const DAMAGE_VERBS = {
        // Kinetic - Bullets
        GUNFIRE: { hit: 'HITS', crit: 'SHREDS', graze: 'grazes', miss: 'misses' },
        BUCKSHOT: { hit: 'BLASTS', crit: 'DEVASTATES', graze: 'peppers', miss: 'sprays wide' },
        SNIPER: { hit: 'PIERCES', crit: 'HEADSHOTS', graze: 'clips', miss: 'misses' },

        // Energy
        LASER: { hit: 'BURNS', crit: 'INCINERATES', graze: 'scorches', miss: 'misses' },
        PLASMA: { hit: 'SEARS', crit: 'VAPORIZES', graze: 'singes', miss: 'misses' },
        BEAM: { hit: 'BLASTS', crit: 'DISINTEGRATES', graze: 'grazes', miss: 'misses' },
        ELECTRIC: { hit: 'SHOCKS', crit: 'ELECTROCUTES', graze: 'zaps', miss: 'arcs wide' },
        ICE: { hit: 'FREEZES', crit: 'FLASH-FREEZES', graze: 'chills', miss: 'misses' },

        // Melee
        SMASHING: { hit: 'SMASHES', crit: 'CRUSHES', graze: 'glances', miss: 'swings wide' },
        EDGED: { hit: 'SLASHES', crit: 'CLEAVES', graze: 'nicks', miss: 'swings wide' },
        PIERCING: { hit: 'STABS', crit: 'IMPALES', graze: 'scratches', miss: 'misses' },
        FISTS: { hit: 'PUNCHES', crit: 'DEMOLISHES', graze: 'clips', miss: 'swings wide' },

        // Explosive
        EXPLOSIVE: { hit: 'BLASTS', crit: 'OBLITERATES', graze: 'catches', miss: 'misses' },
        GRENADE: { hit: 'CATCHES', crit: 'SHREDS', graze: 'peppers', miss: 'misses' }
    };

    // ============ INJURY TABLE (d100) ============
    // Based on Injury_System.csv - triggered on CRIT or overkill
    const INJURY_TABLE = [
        // 1-5: Fatal
        { range: [1, 5], severity: 'FATAL', effects: ['instant_death'], description: 'Catastrophic damage - instantly fatal' },
        // 6-15: Permanent Disability
        { range: [6, 10], severity: 'PERMANENT', effects: ['lost_limb'], description: 'Limb severed or destroyed' },
        { range: [11, 15], severity: 'PERMANENT', effects: ['lost_eye'], description: 'Eye destroyed - permanent vision loss' },
        // 16-30: Critical
        { range: [16, 20], severity: 'CRITICAL', effects: ['bleeding', 'stunned'], description: 'Arterial bleeding - needs immediate aid' },
        { range: [21, 25], severity: 'CRITICAL', effects: ['broken_spine'], description: 'Spinal damage - paralysis risk' },
        { range: [26, 30], severity: 'CRITICAL', effects: ['organ_damage'], description: 'Internal organ damage' },
        // 31-50: Severe
        { range: [31, 35], severity: 'SEVERE', effects: ['broken_arm'], description: 'Arm fractured - weapon use impaired' },
        { range: [36, 40], severity: 'SEVERE', effects: ['broken_leg'], description: 'Leg fractured - movement impaired' },
        { range: [41, 45], severity: 'SEVERE', effects: ['concussion'], description: 'Severe concussion - accuracy impaired' },
        { range: [46, 50], severity: 'SEVERE', effects: ['bleeding'], description: 'Deep laceration - continuous bleeding' },
        // 51-70: Moderate
        { range: [51, 55], severity: 'MODERATE', effects: ['bleeding'], description: 'Bleeding wound' },
        { range: [56, 60], severity: 'MODERATE', effects: ['winded'], description: 'Wind knocked out - AP reduced' },
        { range: [61, 65], severity: 'MODERATE', effects: ['dazed'], description: 'Dazed and confused' },
        { range: [66, 70], severity: 'MODERATE', effects: ['sprain'], description: 'Joint sprain - movement penalty' },
        // 71-85: Minor
        { range: [71, 75], severity: 'MINOR', effects: ['bruised'], description: 'Painful bruising' },
        { range: [76, 80], severity: 'MINOR', effects: ['cut'], description: 'Minor cut - superficial' },
        { range: [81, 85], severity: 'MINOR', effects: ['stunned'], description: 'Momentarily stunned' },
        // 86-95: Light
        { range: [86, 90], severity: 'LIGHT', effects: [], description: 'Grazed - minimal effect' },
        { range: [91, 95], severity: 'LIGHT', effects: [], description: 'Near miss - shaken only' },
        // 96-100: Survivable
        { range: [96, 100], severity: 'LUCKY', effects: [], description: 'Lucky escape - no lasting injury' }
    ];

    // ============ WEAPONS ============
    // SOUND DATA - decibels and hearing range in tiles
    const SOUND_DATA = {
        // Weapons
        pistol: { decibels: 140, baseRange: 50 },
        rifle: { decibels: 160, baseRange: 75 },
        smg: { decibels: 150, baseRange: 60 },
        shotgun: { decibels: 155, baseRange: 70 },
        sniper: { decibels: 160, baseRange: 75 },
        beam: { decibels: 70, baseRange: 15 },       // Energy is quieter
        beam_wide: { decibels: 75, baseRange: 18 },
        plasma_rifle: { decibels: 80, baseRange: 20 },
        ice_rifle: { decibels: 65, baseRange: 12 },
        emp_gun: { decibels: 60, baseRange: 10 },
        fists: { decibels: 50, baseRange: 8 },       // Melee impact
        sword: { decibels: 60, baseRange: 10 },
        super_punch: { decibels: 80, baseRange: 20 }, // Super strength
        // Actions
        walking: { decibels: 30, baseRange: 3 },
        running: { decibels: 50, baseRange: 8 },
        door_break: { decibels: 80, baseRange: 20 },
        scream: { decibels: 80, baseRange: 25 }
    };

    const WEAPONS = {
        pistol: {
            name: 'Pistol', emoji: 'üî´', damage: 20, range: 5, accuracy: 0, ap: 2, drPen: 0,
            damageType: 'GUNFIRE', damageSubtype: 'kinetic',
            sound: SOUND_DATA.pistol,
            visual: { type: 'projectile', color: 0xffff00 }
        },
        rifle: {
            name: 'Assault Rifle', emoji: 'üî´', damage: 25, range: 8, accuracy: 0, ap: 2, drPen: 2,
            damageType: 'GUNFIRE', damageSubtype: 'kinetic',
            sound: SOUND_DATA.rifle,
            visual: { type: 'projectile', color: 0xffff00 }
        },
        smg: {
            name: 'SMG', emoji: 'üî´', damage: 15, range: 4, accuracy: 0, ap: 1, drPen: 0,
            damageType: 'GUNFIRE', damageSubtype: 'kinetic',
            sound: SOUND_DATA.smg,
            visual: { type: 'projectile', color: 0xffff00 }
        },
        shotgun: {
            name: 'Shotgun', emoji: 'üí•', damage: 35, range: 3, accuracy: 0, ap: 2, drPen: 0, closeBonus: 2,
            knockback: 2, // Tiles pushed back
            damageType: 'BUCKSHOT', damageSubtype: 'kinetic',
            sound: SOUND_DATA.shotgun,
            visual: { type: 'cone', color: 0xff8800, spread: 30 }
        },
        sniper: {
            name: 'Sniper Rifle', emoji: 'üéØ', damage: 45, range: 12, accuracy: 2, ap: 3, drPen: 5,
            knockback: 1, // High power impact
            damageType: 'SNIPER', damageSubtype: 'kinetic',
            sound: SOUND_DATA.sniper,
            visual: { type: 'projectile', color: 0xffffff }
        },
        beam: {
            name: 'Energy Beam', emoji: '‚ö°', damage: 30, range: 8, accuracy: 0, ap: 2, ignoresArmor: 0.4,
            damageType: 'BEAM', damageSubtype: 'energy',
            canCauseEffect: 'burning',
            sound: SOUND_DATA.beam,
            visual: { type: 'beam', color: 0x00ffff }
        },
        beam_wide: {
            name: 'Wide Beam', emoji: 'üåä', damage: 25, range: 5, accuracy: 1, ap: 2, ignoresArmor: 0.4,
            damageType: 'BEAM', damageSubtype: 'energy',
            canCauseEffect: 'burning',
            sound: SOUND_DATA.beam_wide,
            visual: { type: 'cone', color: 0x00ffff, spread: 45 }
        },
        plasma_rifle: {
            name: 'Plasma Rifle', emoji: 'üî•', damage: 40, range: 6, accuracy: -1, ap: 3, ignoresArmor: 0.5,
            knockback: 2, // Energy blast impact
            damageType: 'PLASMA', damageSubtype: 'energy',
            canCauseEffect: 'burning',
            sound: SOUND_DATA.plasma_rifle,
            visual: { type: 'projectile', color: 0xff4400 }
        },
        ice_rifle: {
            name: 'Ice Rifle', emoji: '‚ùÑÔ∏è', damage: 25, range: 6, accuracy: 0, ap: 2, ignoresArmor: 0.3,
            damageType: 'ICE', damageSubtype: 'energy',
            canCauseEffect: 'frozen',
            sound: SOUND_DATA.ice_rifle,
            visual: { type: 'beam', color: 0x88ddff }
        },
        emp_gun: {
            name: 'EMP Gun', emoji: 'üì°', damage: 15, range: 5, accuracy: 1, ap: 2,
            damageType: 'ELECTRIC', damageSubtype: 'energy',
            canCauseEffect: 'emp',
            empDamageBonus: 30, // Extra damage vs tech/constructs
            sound: SOUND_DATA.emp_gun,
            visual: { type: 'beam', color: 0x8844ff }
        },
        fists: {
            name: 'Fists', emoji: 'üëä', damage: 8, range: 1, accuracy: 0, ap: 1, strBonus: true, drPen: 0,
            damageType: 'FISTS', damageSubtype: 'melee',
            sound: SOUND_DATA.fists,
            visual: { type: 'melee', color: 0xffffff }
        },
        super_punch: {
            name: 'Super Punch', emoji: 'üí•', damage: 25, range: 1, accuracy: 1, ap: 2, strBonus: true, drPen: 10,
            knockback: 3, // Powerful melee slam
            damageType: 'SMASHING', damageSubtype: 'melee',
            sound: SOUND_DATA.super_punch,
            visual: { type: 'melee', color: 0xff4444 }
        },
        sword: {
            name: 'Sword', emoji: '‚öîÔ∏è', damage: 22, range: 1, accuracy: 1, ap: 2, drPen: 3,
            damageType: 'EDGED', damageSubtype: 'melee',
            canCauseEffect: 'bleeding',
            sound: SOUND_DATA.sword,
            visual: { type: 'melee', color: 0xcccccc }
        }
    };

    // ============ ARMORS ============
    const ARMORS = {
        none: { name: 'None', emoji: 'üëï', dr: 0, energyDR: 0 },
        kevlar: { name: 'Kevlar', emoji: 'ü¶∫', dr: 6, energyDR: 3 },
        tactical: { name: 'Tactical', emoji: 'üéΩ', dr: 8, energyDR: 4 },
        combat: { name: 'Combat', emoji: '‚öôÔ∏è', dr: 12, energyDR: 6 },
        power: { name: 'Power', emoji: 'ü¶æ', dr: 18, energyDR: 12 },
        mystic_ward: { name: 'Mystic Ward', emoji: '‚ú®', dr: 5, energyDR: 15 },
        alien_hide: { name: 'Alien Hide', emoji: 'üõ∏', dr: 14, energyDR: 14 }
    };

    // ============ GRID SETTINGS ============
    const GRID_SIZE = 15;
    const TILE_SIZE = 40;
    const MAP_WIDTH = GRID_SIZE * TILE_SIZE;
    const MAP_HEIGHT = GRID_SIZE * TILE_SIZE;

    const config = {
        type: Phaser.AUTO,
        width: MAP_WIDTH + 100,
        height: MAP_HEIGHT + 100,
        parent: 'game-container',
        backgroundColor: '#16213e',
        scene: { preload, create, update }
    };

    let game;
    let gameState = {
        turn: 1,
        currentTeam: 'a',
        selectedUnit: null,
        units: [],
        grid: [],
        animating: false,
        gameOver: false,
        offsetX: 50,
        offsetY: 50,
        aiVsAi: false,
        playerTeam: 'a', // Which team the player controls ('a' = blue, 'b' = red)
        aiSpeed: 400,
        hoveredCell: null,
        pathPreview: [],
        combatStats: {
            totalDamageDealt: { a: 0, b: 0 },
            totalKills: { a: 0, b: 0 },
            criticalHits: { a: 0, b: 0 },
            misses: { a: 0, b: 0 },
            grazes: { a: 0, b: 0 },
            hits: { a: 0, b: 0 },
            coverSaves: 0,
            armorAbsorbed: { a: 0, b: 0 },
            overkillDamage: { a: 0, b: 0 },
            injuriesInflicted: [],
            killLog: [], // { turn, killer, victim, weapon, overkill }
            shotsFired: { a: 0, b: 0 },
            damageByWeapon: {}, // weaponId: totalDamage
            damageByUnit: {}, // unitName: { dealt, taken, kills, shots, hits, meleeDamage, rangedDamage, rangedShots, rangedHits, team }
            originEffectiveness: {}, // originId: { dealt: X, taken: Y }
            personalityPerformance: {}, // personalityId: { kills: X, damage: Y }
            turnDeaths: [], // { turn, unit }
            longestKillstreak: { unit: null, streak: 0 },
            currentStreaks: {},
            meleeDamage: { a: 0, b: 0 },
            rangedDamage: { a: 0, b: 0 },
            mostDamageTaken: { unit: null, damage: 0 },
            firstBlood: null, // { killer, victim, turn, weapon }
            lastKill: null // { killer, victim, turn, weapon }
        }
    };

    // ============ CAREER HISTORY TRACKING ============
    // Persistent stats across battles stored in localStorage
    const CAREER_STORAGE_KEY = 'sht_career_history';

    function loadCareerHistory() {
        try {
            const saved = localStorage.getItem(CAREER_STORAGE_KEY);
            if (saved) return JSON.parse(saved);
        } catch (e) {
            console.warn('Failed to load career history:', e);
        }
        return {};
    }

    function saveCareerHistory(history) {
        try {
            localStorage.setItem(CAREER_STORAGE_KEY, JSON.stringify(history));
        } catch (e) {
            console.warn('Failed to save career history:', e);
        }
    }

    let careerHistory = loadCareerHistory();

    // Career stats structure for each character
    function getDefaultCareerStats() {
        return {
            battlesTotal: 0,
            battlesWon: 0,
            battlesLost: 0,
            totalKills: 0,
            totalDeaths: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            totalMeleeDamage: 0,
            totalRangedDamage: 0,
            totalRangedShots: 0,
            totalRangedHits: 0,
            totalCriticalHits: 0,
            // Awards tracking
            awards: {
                mvp: 0,           // Most Valuable
                reaper: 0,        // Most Kills in a battle
                deadeye: 0,       // Best overall accuracy
                blueMarksman: 0,  // Best accuracy on blue team
                redMarksman: 0,   // Best accuracy on red team
                brawler: 0,       // Most melee damage
                tank: 0,          // Most damage taken
                executioner: 0,   // Highest overkill
                killingSpree: 0,  // Kill streak
                firstBlood: 0,    // First kill
                finalBlow: 0      // Last kill
            },
            // Per-weapon stats
            weaponKills: {},  // { weaponId: kills }
            // Kill/Death records
            bestKillStreak: 0,
            mostKillsInBattle: 0,
            mostDamageInBattle: 0,
            // Last updated
            lastBattle: null
        };
    }

    function recordCareerStats(winningTeam) {
        const stats = gameState.combatStats;
        const now = new Date().toISOString();

        // Record stats for each combatant
        for (const unit of gameState.units) {
            const charId = unit.id || unit.codename;
            if (!careerHistory[charId]) {
                careerHistory[charId] = {
                    ...getDefaultCareerStats(),
                    name: unit.name,
                    codename: unit.codename,
                    origin: unit.origin.id,
                    personality: unit.personality.id
                };
            }

            const career = careerHistory[charId];
            // Stats are recorded using unit.name, so look up with name not codename
            const battleStats = stats.damageByUnit[unit.name] || {
                dealt: 0, taken: 0, kills: 0, meleeDamage: 0, rangedDamage: 0,
                rangedShots: 0, rangedHits: 0, shots: 0, hits: 0
            };

            // Update battle counts
            career.battlesTotal++;
            if (unit.team === winningTeam) {
                career.battlesWon++;
            } else {
                career.battlesLost++;
            }

            // Update combat stats
            career.totalKills += battleStats.kills;
            career.totalDamageDealt += battleStats.dealt;
            career.totalDamageTaken += battleStats.taken;
            career.totalMeleeDamage += battleStats.meleeDamage;
            career.totalRangedDamage += battleStats.rangedDamage;
            career.totalRangedShots += battleStats.rangedShots;
            career.totalRangedHits += battleStats.rangedHits;

            // Track deaths (killLog uses unit.name not codename)
            const died = stats.killLog.some(k => k.victim === unit.name);
            if (died) career.totalDeaths++;

            // Update records
            if (battleStats.kills > career.mostKillsInBattle) {
                career.mostKillsInBattle = battleStats.kills;
            }
            if (battleStats.dealt > career.mostDamageInBattle) {
                career.mostDamageInBattle = battleStats.dealt;
            }

            career.lastBattle = now;
        }

        // Record awards - find who won each
        const awardWinners = {
            mvp: null,
            reaper: null,
            deadeye: null,
            blueMarksman: null,
            redMarksman: null,
            brawler: null,
            tank: null,
            executioner: null,
            killingSpree: null,
            firstBlood: null,
            finalBlow: null
        };

        // Find MVP (most damage)
        let maxDmg = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.dealt > maxDmg) {
                maxDmg = data.dealt;
                awardWinners.mvp = name;
            }
        }

        // Find Reaper (most kills)
        let maxKills = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.kills > maxKills) {
                maxKills = data.kills;
                awardWinners.reaper = name;
            }
        }

        // Find Deadeye (best ranged accuracy, min 2 shots)
        let maxAcc = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.rangedShots >= 2) {
                const acc = data.rangedHits / data.rangedShots;
                if (acc > maxAcc) {
                    maxAcc = acc;
                    awardWinners.deadeye = name;
                }
            }
        }

        // Find team marksmen
        let blueMaxAcc = 0, redMaxAcc = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.rangedShots >= 2) {
                const acc = data.rangedHits / data.rangedShots;
                if (data.team === 'a' && acc > blueMaxAcc) {
                    blueMaxAcc = acc;
                    awardWinners.blueMarksman = name;
                }
                if (data.team === 'b' && acc > redMaxAcc) {
                    redMaxAcc = acc;
                    awardWinners.redMarksman = name;
                }
            }
        }

        // Find Brawler (most melee damage)
        let maxMelee = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.meleeDamage > maxMelee) {
                maxMelee = data.meleeDamage;
                awardWinners.brawler = name;
            }
        }

        // Tank
        if (stats.mostDamageTaken.unit) {
            awardWinners.tank = stats.mostDamageTaken.unit;
        }

        // Executioner (highest overkill)
        let maxOverkill = 10; // Only count if > 10
        for (const kill of stats.killLog) {
            if (kill.overkill > maxOverkill) {
                maxOverkill = kill.overkill;
                awardWinners.executioner = kill.killer;
            }
        }

        // Kill streak
        if (stats.longestKillstreak.streak > 1) {
            awardWinners.killingSpree = stats.longestKillstreak.unit;
        }

        // First blood & final blow
        if (stats.firstBlood) {
            awardWinners.firstBlood = stats.firstBlood.killer;
        }
        if (stats.lastKill && stats.killLog.length > 1) {
            awardWinners.finalBlow = stats.lastKill.killer;
        }

        // Award credits to characters
        for (const unit of gameState.units) {
            const charId = unit.id || unit.codename;
            const career = careerHistory[charId];
            if (!career) continue;

            const codename = unit.codename;
            for (const [award, winner] of Object.entries(awardWinners)) {
                if (winner === codename) {
                    career.awards[award] = (career.awards[award] || 0) + 1;
                }
            }

            // Update kill streak record
            const currentStreak = stats.currentStreaks[codename] || 0;
            if (currentStreak > career.bestKillStreak) {
                career.bestKillStreak = currentStreak;
            }
        }

        // Save to localStorage
        saveCareerHistory(careerHistory);
        console.log('Career history updated:', careerHistory);
    }

    function showCareerHistory(charId) {
        const career = careerHistory[charId];
        if (!career) {
            addLog(`No career history found for ${charId}`, 'system');
            return;
        }

        const log = document.getElementById('combat-log');
        log.innerHTML = '';

        const winRate = career.battlesTotal > 0
            ? Math.round(career.battlesWon / career.battlesTotal * 100)
            : 0;
        const kd = career.totalDeaths > 0
            ? (career.totalKills / career.totalDeaths).toFixed(2)
            : career.totalKills.toFixed(0);
        const accuracy = career.totalRangedShots > 0
            ? Math.round(career.totalRangedHits / career.totalRangedShots * 100)
            : 0;

        addLog('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'effect');
        addLog(`‚ïë  üìä CAREER: ${career.codename.toUpperCase().padEnd(16)}  ‚ïë`, 'effect');
        addLog('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'effect');
        addLog('', 'system');

        addLog('üìã OVERVIEW', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        addLog(`‚öîÔ∏è Battles: ${career.battlesTotal} (${career.battlesWon}W / ${career.battlesLost}L) - ${winRate}%`, 'system');
        addLog(`üíÄ K/D: ${career.totalKills} kills / ${career.totalDeaths} deaths = ${kd}`, 'system');
        addLog(`üéØ Accuracy: ${accuracy}% (${career.totalRangedHits}/${career.totalRangedShots})`, 'system');
        addLog(`üí• Total Damage: ${career.totalDamageDealt} dealt / ${career.totalDamageTaken} taken`, 'system');
        addLog(`   üî´ Ranged: ${career.totalRangedDamage} | üëä Melee: ${career.totalMeleeDamage}`, 'system');
        addLog('', 'system');

        addLog('üèÜ AWARDS', 'effect');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        const awards = career.awards;
        if (awards.mvp) addLog(`ü•á MOST VALUABLE: ${awards.mvp}x`, 'move');
        if (awards.reaper) addLog(`üíÄ THE REAPER: ${awards.reaper}x`, 'kill');
        if (awards.deadeye) addLog(`üéØ DEADEYE: ${awards.deadeye}x`, 'move');
        if (awards.blueMarksman) addLog(`üîµ BLUE MARKSMAN: ${awards.blueMarksman}x`, 'move');
        if (awards.redMarksman) addLog(`üî¥ RED MARKSMAN: ${awards.redMarksman}x`, 'attack');
        if (awards.brawler) addLog(`üëä THE BRAWLER: ${awards.brawler}x`, 'attack');
        if (awards.tank) addLog(`üõ°Ô∏è THE TANK: ${awards.tank}x`, 'system');
        if (awards.executioner) addLog(`‚ò†Ô∏è THE EXECUTIONER: ${awards.executioner}x`, 'kill');
        if (awards.killingSpree) addLog(`üî• KILLING SPREE: ${awards.killingSpree}x`, 'kill');
        if (awards.firstBlood) addLog(`ü©∏ FIRST BLOOD: ${awards.firstBlood}x`, 'kill');
        if (awards.finalBlow) addLog(`‚ö∞Ô∏è FINAL BLOW: ${awards.finalBlow}x`, 'kill');

        const totalAwards = Object.values(awards).reduce((a, b) => a + b, 0);
        if (totalAwards === 0) {
            addLog('   No awards yet - keep fighting!', 'system');
        }
        addLog('', 'system');

        addLog('üìà RECORDS', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        addLog(`üî• Best Kill Streak: ${career.bestKillStreak}`, 'kill');
        addLog(`üíÄ Most Kills (single battle): ${career.mostKillsInBattle}`, 'kill');
        addLog(`üí• Most Damage (single battle): ${career.mostDamageInBattle}`, 'damage');
        addLog('', 'system');

        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        addLog('üîÑ Click battle to return to results', 'system');
    }

    function showAllCareers() {
        const log = document.getElementById('combat-log');
        log.innerHTML = '';

        const careers = Object.entries(careerHistory).sort((a, b) => {
            return (b[1].battlesWon || 0) - (a[1].battlesWon || 0);
        });

        addLog('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'effect');
        addLog('‚ïë  üìä ALL-TIME CAREER RANKINGS  ‚ïë', 'effect');
        addLog('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'effect');
        addLog('', 'system');

        if (careers.length === 0) {
            addLog('No career data yet. Complete a battle!', 'system');
            return;
        }

        // Sort by different metrics
        addLog('üèÜ BY WIN RATE (min 3 battles)', 'effect');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        const byWinRate = careers
            .filter(([id, c]) => c.battlesTotal >= 3)
            .sort((a, b) => {
                const wrA = a[1].battlesWon / a[1].battlesTotal;
                const wrB = b[1].battlesWon / b[1].battlesTotal;
                return wrB - wrA;
            })
            .slice(0, 5);

        byWinRate.forEach(([id, c], i) => {
            const wr = Math.round(c.battlesWon / c.battlesTotal * 100);
            addLog(`${i+1}. ${c.codename}: ${wr}% (${c.battlesWon}W/${c.battlesLost}L)`, 'system');
        });
        if (byWinRate.length === 0) addLog('   Need more battles!', 'system');
        addLog('', 'system');

        addLog('üíÄ BY TOTAL KILLS', 'kill');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        const byKills = careers.sort((a, b) => b[1].totalKills - a[1].totalKills).slice(0, 5);
        byKills.forEach(([id, c], i) => {
            addLog(`${i+1}. ${c.codename}: ${c.totalKills} kills`, 'system');
        });
        addLog('', 'system');

        addLog('üí• BY TOTAL DAMAGE', 'damage');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        const byDamage = careers.sort((a, b) => b[1].totalDamageDealt - a[1].totalDamageDealt).slice(0, 5);
        byDamage.forEach(([id, c], i) => {
            addLog(`${i+1}. ${c.codename}: ${c.totalDamageDealt} damage`, 'system');
        });
        addLog('', 'system');

        addLog('ü•á BY MVP AWARDS', 'move');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        const byMVP = careers
            .filter(([id, c]) => c.awards.mvp > 0)
            .sort((a, b) => b[1].awards.mvp - a[1].awards.mvp)
            .slice(0, 5);
        byMVP.forEach(([id, c], i) => {
            addLog(`${i+1}. ${c.codename}: ${c.awards.mvp}x MVP`, 'system');
        });
        if (byMVP.length === 0) addLog('   No MVPs yet!', 'system');
        addLog('', 'system');

        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        addLog('üíæ Data persists in browser storage', 'system');
        addLog('üîÑ Refresh to start new battle', 'system');
    }

    function getCareerSnippet(unit) {
        const charId = unit.id || unit.codename;
        const career = careerHistory[charId];
        if (!career || career.battlesTotal === 0) {
            return '<div style="margin-top: 6px; font-size: 10px; color: #666; font-style: italic;">No career history yet</div>';
        }

        const winRate = Math.round(career.battlesWon / career.battlesTotal * 100);
        const kd = career.totalDeaths > 0
            ? (career.totalKills / career.totalDeaths).toFixed(1)
            : career.totalKills.toString();

        // Get top award
        let topAward = '';
        const awards = career.awards;
        if (awards.mvp >= 2) topAward = `ü•á${awards.mvp}`;
        else if (awards.reaper >= 2) topAward = `üíÄ${awards.reaper}`;
        else if (awards.deadeye >= 2) topAward = `üéØ${awards.deadeye}`;

        return `
            <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #333; font-size: 10px;">
                <div style="color: #f39c12; font-weight: bold;">üìä Career Stats</div>
                <div style="color: #888;">${career.battlesTotal} battles (${winRate}% WR) ‚Ä¢ ${career.totalKills} kills ‚Ä¢ K/D ${kd} ${topAward}</div>
            </div>
        `;
    }

    function preload() {}

    function create() {
        const scene = this;
        gameState.scene = scene; // Store scene reference for LOS indicator
        createGrid(scene);
        createObstacles(scene);
        createUnits(scene);
        setupInput(scene);
        createUnitCards();
        document.getElementById('end-turn-btn').onclick = endTurn;
        document.getElementById('team-select-btn').onclick = togglePlayerTeam;
        document.getElementById('ai-vs-ai-btn').onclick = toggleAiVsAi;
        document.getElementById('roster-btn').onclick = openRosterModal;
        document.getElementById('careers-btn').onclick = showAllCareers;
        addLog('‚öîÔ∏è Combat initiated!', 'system');
        addLog('üñ±Ô∏è Click a blue unit, then move or attack.', 'system');
        addLog('ü§ñ Press "AI vs AI" to watch automated combat!', 'system');
        addLog('üìä Press "CAREERS" to view all-time stats!', 'system');
        addLog('üëÅÔ∏è Fog of War active - enemies hide behind walls!', 'system');
        selectUnit(gameState.units.find(u => u.team === 'a'));
        refreshVisibility(); // Initialize fog of war
    }

    function update() {}

    // ============ CHARACTER CREATION ============
    function createCharacter(def) {
        const origin = ORIGINS[def.origin] || ORIGINS.skilled_human;
        const personality = PERSONALITIES[def.personality] || PERSONALITIES.tactical;
        const weapon = WEAPONS[def.weapon] || WEAPONS.fists;
        const armor = ARMORS[def.armor] || ARMORS.none;

        return {
            // Identity
            id: def.id,
            name: def.name,
            codename: def.codename || def.name,
            secretIdentity: def.secretIdentity || null,
            team: def.team,

            // Origin & Personality
            origin: origin,
            personality: personality,
            threatLevel: def.threatLevel || 'level1',

            // Position
            x: def.x,
            y: def.y,

            // Combat Stats
            hp: def.hp || 100,
            maxHp: def.hp || 100,
            ap: def.ap || 6,
            maxAp: def.ap || 6,

            // Primary Attributes
            str: def.str || 30,
            agl: def.agl || 30,
            end: def.end || 30,
            rsn: def.rsn || 30,
            int: def.int || 30,
            psy: def.psy || 30,

            // Equipment
            weaponId: def.weapon,
            armorId: def.armor,

            // Status
            statusEffects: [],
            injuries: [],
            acted: false,

            // STAM Evaluation (for AI analysis)
            stamPersonality: def.stamPersonality || 5,
            stamMotivation: def.stamMotivation || 5,
            stamHarmPotential: def.stamHarmPotential || 5,

            // Visual references (set during createUnit)
            sprite: null,
            hpBar: null,
            hpBg: null,
            nameText: null,
            effectsContainer: null
        };
    }

    // ============ ROSTER MANAGEMENT ============
    let rosterState = {
        blueTeam: [],
        redTeam: [],
        available: [],
        selected: null
    };

    // Default characters that come with the game
    const DEFAULT_CHARACTERS = [
        { id: 'def-1', name: 'ALPHA', codename: 'Alpha', hp: 100, str: 30, agl: 35, end: 30, rsn: 30, int: 30, psy: 30,
          origin: 'skilled_human', personality: 'tactical', weapon: 'rifle', armor: 'tactical', threatLevel: 'level2' },
        { id: 'def-2', name: 'BRAVO', codename: 'Bravo', hp: 100, str: 35, agl: 30, end: 35, rsn: 25, int: 30, psy: 25,
          origin: 'altered_human', personality: 'aggressive', weapon: 'shotgun', armor: 'kevlar', threatLevel: 'level2' },
        { id: 'def-3', name: 'CHARLIE', codename: 'Sharpshot', hp: 80, str: 25, agl: 40, end: 25, rsn: 35, int: 40, psy: 30,
          origin: 'skilled_human', personality: 'sniper', weapon: 'sniper', armor: 'kevlar', threatLevel: 'level2' },
        { id: 'def-4', name: 'DELTA', codename: 'Energon', hp: 100, str: 30, agl: 35, end: 30, rsn: 40, int: 35, psy: 45,
          origin: 'mutant', personality: 'calculating', weapon: 'beam', armor: 'tactical', threatLevel: 'level3' },
        { id: 'def-5', name: 'RED-1', codename: 'Red Leader', hp: 100, str: 30, agl: 35, end: 30, rsn: 35, int: 35, psy: 30,
          origin: 'skilled_human', personality: 'tactical', weapon: 'rifle', armor: 'tactical', threatLevel: 'level2' },
        { id: 'def-6', name: 'RED-2', codename: 'Blitz', hp: 100, str: 30, agl: 40, end: 30, rsn: 30, int: 35, psy: 25,
          origin: 'tech_enhanced', personality: 'aggressive', weapon: 'smg', armor: 'kevlar', threatLevel: 'level2' },
        { id: 'def-7', name: 'RED-3', codename: 'Terminus', hp: 150, str: 35, agl: 30, end: 50, rsn: 40, int: 35, psy: 20,
          origin: 'construct', personality: 'cold', weapon: 'beam_wide', armor: 'combat', threatLevel: 'level3' },
        { id: 'def-8', name: 'RED-4', codename: 'Crusher', hp: 100, str: 45, agl: 30, end: 40, rsn: 20, int: 25, psy: 20,
          origin: 'altered_human', personality: 'berserker', weapon: 'super_punch', armor: 'kevlar', threatLevel: 'level2' }
    ];

    function openRosterModal() {
        // Load custom characters from localStorage
        const customChars = JSON.parse(localStorage.getItem('sht_custom_characters') || '[]');

        // Combine default and custom characters
        const allChars = [...DEFAULT_CHARACTERS, ...customChars];

        // Initialize roster state
        rosterState.available = allChars;
        rosterState.blueTeam = [];
        rosterState.redTeam = [];
        rosterState.selected = null;

        // Pre-populate teams with defaults
        rosterState.blueTeam = allChars.filter(c => c.id.startsWith('def-') && parseInt(c.id.split('-')[1]) <= 4).map(c => ({...c}));
        rosterState.redTeam = allChars.filter(c => c.id.startsWith('def-') && parseInt(c.id.split('-')[1]) > 4).map(c => ({...c}));
        rosterState.available = allChars.filter(c => !c.id.startsWith('def-'));

        renderRoster();
        document.getElementById('roster-modal').style.display = 'block';
    }

    function closeRosterModal() {
        document.getElementById('roster-modal').style.display = 'none';
    }

    function renderRoster() {
        // Render Blue Team
        const blueDiv = document.getElementById('blue-team-roster');
        blueDiv.innerHTML = rosterState.blueTeam.map((char, idx) => `
            <div onclick="selectRosterChar('blue', ${idx})" style="
                padding: 10px; margin-bottom: 8px; background: ${rosterState.selected?.team === 'blue' && rosterState.selected?.idx === idx ? 'rgba(52, 152, 219, 0.5)' : 'rgba(0,0,0,0.3)'};
                border: 2px solid ${rosterState.selected?.team === 'blue' && rosterState.selected?.idx === idx ? '#3498db' : '#333'};
                border-radius: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <span style="font-size: 18px;">${ORIGINS[char.origin]?.emoji || 'üßë'}</span>
                    <strong>${char.codename}</strong>
                    <span style="color: #888; font-size: 12px;">(${char.threatLevel})</span>
                </div>
                <button onclick="event.stopPropagation(); removeFromTeam('blue', ${idx})" style="background: #e74c3c; border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚úñÔ∏è</button>
            </div>
        `).join('') || '<div style="color: #666; text-align: center; padding: 20px;">Drag characters here</div>';

        // Render Red Team
        const redDiv = document.getElementById('red-team-roster');
        redDiv.innerHTML = rosterState.redTeam.map((char, idx) => `
            <div onclick="selectRosterChar('red', ${idx})" style="
                padding: 10px; margin-bottom: 8px; background: ${rosterState.selected?.team === 'red' && rosterState.selected?.idx === idx ? 'rgba(231, 76, 60, 0.5)' : 'rgba(0,0,0,0.3)'};
                border: 2px solid ${rosterState.selected?.team === 'red' && rosterState.selected?.idx === idx ? '#e74c3c' : '#333'};
                border-radius: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <span style="font-size: 18px;">${ORIGINS[char.origin]?.emoji || 'üßë'}</span>
                    <strong>${char.codename}</strong>
                    <span style="color: #888; font-size: 12px;">(${char.threatLevel})</span>
                </div>
                <button onclick="event.stopPropagation(); removeFromTeam('red', ${idx})" style="background: #e74c3c; border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚úñÔ∏è</button>
            </div>
        `).join('') || '<div style="color: #666; text-align: center; padding: 20px;">Drag characters here</div>';

        // Render Available Characters
        const availDiv = document.getElementById('available-roster');
        const customChars = JSON.parse(localStorage.getItem('sht_custom_characters') || '[]');
        const allAvailable = [...DEFAULT_CHARACTERS, ...customChars];

        availDiv.innerHTML = allAvailable.map((char, idx) => `
            <div onclick="selectAvailableChar(${idx})" style="
                padding: 12px; background: ${rosterState.selected?.team === 'available' && rosterState.selected?.idx === idx ? 'rgba(243, 156, 18, 0.3)' : 'rgba(0,0,0,0.3)'};
                border: 2px solid ${rosterState.selected?.team === 'available' && rosterState.selected?.idx === idx ? '#f39c12' : '#444'};
                border-radius: 8px; cursor: pointer;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 24px;">${ORIGINS[char.origin]?.emoji || 'üßë'}</span>
                    <div>
                        <div style="font-weight: bold;">${char.codename}</div>
                        <div style="font-size: 11px; color: #888;">${char.name}</div>
                    </div>
                </div>
                <div style="display: flex; gap: 15px; font-size: 11px; color: #aaa;">
                    <span>HP: ${char.hp}</span>
                    <span>${WEAPONS[char.weapon]?.name || char.weapon}</span>
                    <span>${char.threatLevel}</span>
                </div>
                <div style="margin-top: 8px; display: flex; gap: 5px;">
                    <button onclick="event.stopPropagation(); addToTeam('blue', ${idx})" style="flex: 1; padding: 5px; background: #3498db; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">+ Blue</button>
                    <button onclick="event.stopPropagation(); addToTeam('red', ${idx})" style="flex: 1; padding: 5px; background: #e74c3c; border: none; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">+ Red</button>
                </div>
            </div>
        `).join('') || '<div style="color: #666; text-align: center; padding: 20px;">No characters available. Create some!</div>';
    }

    function selectRosterChar(team, idx) {
        rosterState.selected = { team, idx };
        renderRoster();
    }

    function selectAvailableChar(idx) {
        rosterState.selected = { team: 'available', idx };
        renderRoster();
    }

    function addToTeam(team, availableIdx) {
        const customChars = JSON.parse(localStorage.getItem('sht_custom_characters') || '[]');
        const allAvailable = [...DEFAULT_CHARACTERS, ...customChars];
        const char = {...allAvailable[availableIdx]};

        if (team === 'blue') {
            if (rosterState.blueTeam.length < 6) {
                rosterState.blueTeam.push(char);
            } else {
                alert('Blue team is full (max 6)');
            }
        } else {
            if (rosterState.redTeam.length < 6) {
                rosterState.redTeam.push(char);
            } else {
                alert('Red team is full (max 6)');
            }
        }
        renderRoster();
    }

    function removeFromTeam(team, idx) {
        if (team === 'blue') {
            rosterState.blueTeam.splice(idx, 1);
        } else {
            rosterState.redTeam.splice(idx, 1);
        }
        rosterState.selected = null;
        renderRoster();
    }

    function moveToRed() {
        if (rosterState.selected?.team === 'blue') {
            const char = rosterState.blueTeam.splice(rosterState.selected.idx, 1)[0];
            if (rosterState.redTeam.length < 6) {
                rosterState.redTeam.push(char);
            } else {
                rosterState.blueTeam.push(char); // Put it back
                alert('Red team is full (max 6)');
            }
            rosterState.selected = null;
            renderRoster();
        }
    }

    function moveToBlue() {
        if (rosterState.selected?.team === 'red') {
            const char = rosterState.redTeam.splice(rosterState.selected.idx, 1)[0];
            if (rosterState.blueTeam.length < 6) {
                rosterState.blueTeam.push(char);
            } else {
                rosterState.redTeam.push(char); // Put it back
                alert('Blue team is full (max 6)');
            }
            rosterState.selected = null;
            renderRoster();
        }
    }

    function openCharacterCreator() {
        window.open('character_creator.html', '_blank', 'width=1400,height=900');
    }

    function startBattleWithRoster() {
        if (rosterState.blueTeam.length === 0 || rosterState.redTeam.length === 0) {
            alert('Both teams need at least 1 character!');
            return;
        }

        // Close modal
        closeRosterModal();

        // Clear current game state
        const scene = game.scene.scenes[0];

        // Remove existing unit sprites
        gameState.units.forEach(unit => {
            if (unit.sprite) unit.sprite.destroy();
            if (unit.hpBar) unit.hpBar.destroy();
            if (unit.hpBg) unit.hpBg.destroy();
            if (unit.nameText) unit.nameText.destroy();
            if (unit.effectsContainer) unit.effectsContainer.destroy();
        });

        // Clear grid units
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if (gameState.grid[y] && gameState.grid[y][x]) {
                    gameState.grid[y][x].unit = null;
                }
            }
        }

        // Reset game state
        gameState.units = [];
        gameState.turn = 1;
        gameState.currentTeam = 'a';
        gameState.gameOver = false;
        gameState.selectedUnit = null;
        gameState.combatStats = {
            totalDamageDealt: { a: 0, b: 0 },
            totalKills: { a: 0, b: 0 },
            criticalHits: { a: 0, b: 0 },
            misses: { a: 0, b: 0 },
            grazes: { a: 0, b: 0 },
            hits: { a: 0, b: 0 },
            coverSaves: 0,
            armorAbsorbed: { a: 0, b: 0 },
            overkillDamage: { a: 0, b: 0 },
            injuriesInflicted: [],
            killLog: [],
            shotsFired: { a: 0, b: 0 },
            damageByWeapon: {},
            damageByUnit: {},
            originEffectiveness: {},
            personalityPerformance: {},
            firstBlood: null,
            lastKill: null,
            turnDeaths: [],
            currentStreaks: {},
            longestKillstreak: { unit: null, streak: 0 },
            mostDamageTaken: { unit: null, damage: 0 }
        };

        // Spawn positions
        const blueSpawns = [[1,5], [1,7], [1,9], [2,4], [2,6], [2,8]];
        const redSpawns = [[13,5], [13,7], [13,9], [12,4], [12,6], [12,8]];

        // Create blue team units
        rosterState.blueTeam.forEach((char, idx) => {
            const spawn = blueSpawns[idx] || [1, 5 + idx];
            const def = {
                ...char,
                id: idx,
                team: 'a',
                x: spawn[0],
                y: spawn[1]
            };
            const character = createCharacter(def);
            const unit = createUnitVisuals(scene, character);
            gameState.units.push(unit);
            gameState.grid[spawn[1]][spawn[0]].unit = unit;
        });

        // Create red team units
        rosterState.redTeam.forEach((char, idx) => {
            const spawn = redSpawns[idx] || [13, 5 + idx];
            const def = {
                ...char,
                id: 100 + idx,
                team: 'b',
                x: spawn[0],
                y: spawn[1]
            };
            const character = createCharacter(def);
            const unit = createUnitVisuals(scene, character);
            gameState.units.push(unit);
            gameState.grid[spawn[1]][spawn[0]].unit = unit;
        });

        // Refresh UI
        createUnitCards();
        clearLog();
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'system');
        addLog('‚öîÔ∏è NEW BATTLE STARTED WITH CUSTOM ROSTER!', 'system');
        addLog(`üîµ Blue Team: ${rosterState.blueTeam.length} fighters`, 'system');
        addLog(`üî¥ Red Team: ${rosterState.redTeam.length} fighters`, 'system');
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'system');

        refreshVisibility();
        updateFogOfWar();

        // Select first blue unit
        const firstBlue = gameState.units.find(u => u.team === 'a');
        if (firstBlue) selectUnit(firstBlue);

        // Update turn indicator
        document.getElementById('turn-indicator').innerHTML = 'Turn 1 - <span class="team-a">üîµ BLUE TEAM</span>';
    }

    function clearLog() {
        document.getElementById('combat-log').innerHTML = '';
    }

    // ============ GRID ============
    function createGrid(scene) {
        gameState.gridGraphics = scene.add.graphics();
        gameState.highlightGraphics = scene.add.graphics();
        gameState.pathGraphics = scene.add.graphics();

        for (let y = 0; y < GRID_SIZE; y++) {
            gameState.grid[y] = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                gameState.grid[y][x] = { x, y, walkable: true, unit: null, cover: 0 };
                const px = gameState.offsetX + x * TILE_SIZE;
                const py = gameState.offsetY + y * TILE_SIZE;
                const color = (x + y) % 2 === 0 ? 0x2a2a4a : 0x252545;
                gameState.gridGraphics.fillStyle(color, 1);
                gameState.gridGraphics.fillRect(px, py, TILE_SIZE - 1, TILE_SIZE - 1);
            }
        }
    }

    function createObstacles(scene) {
        const obstacles = [
            { x: 3, y: 3, type: 'wall' }, { x: 3, y: 4, type: 'wall' },
            { x: 7, y: 7, type: 'wall' }, { x: 8, y: 7, type: 'wall' },
            { x: 11, y: 3, type: 'wall' }, { x: 11, y: 4, type: 'wall' },
            { x: 5, y: 10, type: 'cover' }, { x: 9, y: 10, type: 'cover' }, { x: 7, y: 5, type: 'cover' },
            { x: 4, y: 7, type: 'cover' }, { x: 10, y: 7, type: 'cover' },
        ];
        obstacles.forEach(obs => {
            const cell = gameState.grid[obs.y][obs.x];
            const px = gameState.offsetX + obs.x * TILE_SIZE;
            const py = gameState.offsetY + obs.y * TILE_SIZE;
            if (obs.type === 'wall') {
                cell.walkable = false;
                gameState.gridGraphics.fillStyle(0x444466, 1);
            } else {
                cell.cover = 1;
                gameState.gridGraphics.fillStyle(0x336633, 1);
            }
            gameState.gridGraphics.fillRect(px, py, TILE_SIZE - 1, TILE_SIZE - 1);
        });
    }

    // ============ UNITS ============
    function createUnits(scene) {
        // Diverse team with different origins and personalities
        const defs = [
            // BLUE TEAM - mixed origins
            { id: 0, name: 'ALPHA', codename: 'Alpha', team: 'a', x: 1, y: 7, weapon: 'rifle', armor: 'tactical',
              hp: 100, str: 30, agl: 35, origin: 'skilled_human', personality: 'tactical', threatLevel: 'level2' },
            { id: 1, name: 'BRAVO', codename: 'Bravo', team: 'a', x: 2, y: 5, weapon: 'shotgun', armor: 'kevlar',
              hp: 100, str: 35, agl: 30, origin: 'altered_human', personality: 'aggressive', threatLevel: 'level2' },
            { id: 2, name: 'CHARLIE', codename: 'Sharpshot', team: 'a', x: 1, y: 9, weapon: 'sniper', armor: 'kevlar',
              hp: 80, str: 25, agl: 40, origin: 'skilled_human', personality: 'sniper', threatLevel: 'level2' },
            { id: 3, name: 'DELTA', codename: 'Energon', team: 'a', x: 2, y: 11, weapon: 'beam', armor: 'tactical',
              hp: 100, str: 30, agl: 35, origin: 'mutant', personality: 'calculating', threatLevel: 'level3' },

            // RED TEAM - enemy combatants with varied types
            { id: 4, name: 'RED-1', codename: 'Red Leader', team: 'b', x: 13, y: 7, weapon: 'rifle', armor: 'tactical',
              hp: 100, str: 30, agl: 35, origin: 'skilled_human', personality: 'tactical', threatLevel: 'level2' },
            { id: 5, name: 'RED-2', codename: 'Blitz', team: 'b', x: 12, y: 5, weapon: 'smg', armor: 'kevlar',
              hp: 100, str: 30, agl: 40, origin: 'tech_enhanced', personality: 'aggressive', threatLevel: 'level2' },
            { id: 6, name: 'RED-3', codename: 'Terminus', team: 'b', x: 13, y: 9, weapon: 'beam_wide', armor: 'combat',
              hp: 120, str: 35, agl: 30, origin: 'construct', personality: 'cold', threatLevel: 'level3' },
            { id: 7, name: 'RED-4', codename: 'Crusher', team: 'b', x: 12, y: 11, weapon: 'shotgun', armor: 'kevlar',
              hp: 100, str: 40, agl: 30, origin: 'altered_human', personality: 'berserker', threatLevel: 'level2' },
        ];

        defs.forEach((def) => {
            const character = createCharacter(def);
            const unit = createUnitVisuals(scene, character);
            gameState.units.push(unit);
            gameState.grid[def.y][def.x].unit = unit;
        });
    }

    function createUnitVisuals(scene, character) {
        const px = gameState.offsetX + character.x * TILE_SIZE + TILE_SIZE / 2;
        const py = gameState.offsetY + character.y * TILE_SIZE + TILE_SIZE / 2;
        const color = character.team === 'a' ? 0x3498db : 0xe74c3c;

        const circle = scene.add.circle(px, py, 14, color);
        circle.setStrokeStyle(3, 0xffffff);
        circle.setInteractive();

        const hpBg = scene.add.rectangle(px, py - 22, 30, 6, 0x333333);
        const hpBar = scene.add.rectangle(px, py - 22, 30, 6, 0x2ecc71);
        hpBar.setOrigin(0.5, 0.5);

        // Name with origin emoji
        const displayName = `${character.origin.emoji} ${character.name}`;
        const nameText = scene.add.text(px, py + 22, displayName, {
            fontSize: '9px', color: '#fff', stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5);

        // Status effects container
        const effectsContainer = scene.add.container(px, py - 32);

        character.sprite = circle;
        character.hpBar = hpBar;
        character.hpBg = hpBg;
        character.nameText = nameText;
        character.effectsContainer = effectsContainer;

        return character;
    }

    function updateUnitVisuals(unit) {
        const px = gameState.offsetX + unit.x * TILE_SIZE + TILE_SIZE / 2;
        const py = gameState.offsetY + unit.y * TILE_SIZE + TILE_SIZE / 2;
        unit.sprite.setPosition(px, py);
        unit.hpBg.setPosition(px, py - 22);
        unit.hpBar.setPosition(px, py - 22);
        unit.hpBar.width = Math.max(1, (unit.hp / unit.maxHp) * 30);
        unit.nameText.setPosition(px, py + 22);
        unit.effectsContainer.setPosition(px, py - 32);

        const hpPct = unit.hp / unit.maxHp;
        unit.hpBar.fillColor = hpPct > 0.6 ? 0x2ecc71 : (hpPct > 0.3 ? 0xf39c12 : 0xe74c3c);

        // Update status effect icons on sprite
        updateUnitStatusIcons(unit);
    }

    function updateUnitStatusIcons(unit) {
        if (!unit.effectsContainer || !gameState.scene) return;

        // Clear existing effect icons
        unit.effectsContainer.removeAll(true);

        if (unit.statusEffects.length === 0) return;

        // Create status effect emojis above unit
        const effectEmojis = unit.statusEffects.map(e => STATUS_EFFECTS[e.id]?.emoji || '‚ùì').join('');

        const effectText = gameState.scene.add.text(0, 0, effectEmojis, {
            fontSize: '12px',
            fontFamily: 'Arial'
        }).setOrigin(0.5);

        // Add background for visibility
        const bg = gameState.scene.add.rectangle(0, 0, effectText.width + 4, 16, 0x000000, 0.7);
        bg.setStrokeStyle(1, 0xff0000);

        unit.effectsContainer.add(bg);
        unit.effectsContainer.add(effectText);
    }

    // ============ INPUT & HOVER SYSTEM ============
    function setupInput(scene) {
        scene.input.on('pointerdown', (pointer) => {
            // Block input if not player's turn (unless AI vs AI)
            if (gameState.animating || (gameState.currentTeam !== gameState.playerTeam && !gameState.aiVsAi)) return;
            if (gameState.aiVsAi) return; // Let AI handle in AI vs AI mode

            const gridX = Math.floor((pointer.x - gameState.offsetX) / TILE_SIZE);
            const gridY = Math.floor((pointer.y - gameState.offsetY) / TILE_SIZE);
            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) return;

            const cell = gameState.grid[gridY][gridX];
            const selected = gameState.selectedUnit;

            // Click on friendly unit = select it
            if (cell.unit && cell.unit.team === gameState.playerTeam && !cell.unit.acted) {
                selectUnit(cell.unit);
                return;
            }

            if (!selected || selected.acted) return;

            // Click on enemy = attack
            if (cell.unit && cell.unit.team === 'b') {
                handleAttackClick(selected, cell.unit, scene);
                return;
            }

            // Click on empty walkable tile = move
            if (cell.walkable && !cell.unit) {
                handleMoveClick(selected, gridX, gridY, scene);
            }
        });

        // Hover for path preview and attack indicators
        scene.input.on('pointermove', (pointer) => {
            if (gameState.animating || gameState.currentTeam !== gameState.playerTeam) return;

            const gridX = Math.floor((pointer.x - gameState.offsetX) / TILE_SIZE);
            const gridY = Math.floor((pointer.y - gameState.offsetY) / TILE_SIZE);

            if (gridX < 0 || gridX >= GRID_SIZE || gridY < 0 || gridY >= GRID_SIZE) {
                clearPathPreview();
                hideHoverInfo();
                hideTooltip();
                return;
            }

            const cell = gameState.grid[gridY][gridX];
            const selected = gameState.selectedUnit;

            // Show character tooltip on hover
            if (cell.unit) {
                showTooltip(cell.unit, pointer);
            } else {
                hideTooltip();
            }

            if (!selected || selected.acted) {
                clearPathPreview();
                hideHoverInfo();
                return;
            }

            // Hover over enemy = show attack info
            if (cell.unit && cell.unit.team !== selected.team) {
                clearPathPreview();
                showAttackPreview(selected, cell.unit);
                return;
            }

            // Hover over walkable tile = show path preview
            if (cell.walkable && !cell.unit) {
                showPathPreview(selected, gridX, gridY);
            } else {
                clearPathPreview();
                hideHoverInfo();
            }
        });
    }

    function showPathPreview(unit, targetX, targetY) {
        const path = findPath(unit.x, unit.y, targetX, targetY);
        gameState.pathGraphics.clear();

        if (!path) {
            hideHoverInfo();
            return;
        }

        const distance = path.length - 1;
        const apCost = Math.ceil(distance / 2);
        const canAfford = unit.ap >= apCost;

        // Draw path
        gameState.pathGraphics.lineStyle(3, canAfford ? 0x3498db : 0xe74c3c, 0.8);
        gameState.pathGraphics.beginPath();

        for (let i = 0; i < path.length; i++) {
            const px = gameState.offsetX + path[i].x * TILE_SIZE + TILE_SIZE / 2;
            const py = gameState.offsetY + path[i].y * TILE_SIZE + TILE_SIZE / 2;
            if (i === 0) {
                gameState.pathGraphics.moveTo(px, py);
            } else {
                gameState.pathGraphics.lineTo(px, py);
            }
        }
        gameState.pathGraphics.strokePath();

        // Draw destination marker
        const destPx = gameState.offsetX + targetX * TILE_SIZE + TILE_SIZE / 2;
        const destPy = gameState.offsetY + targetY * TILE_SIZE + TILE_SIZE / 2;
        gameState.pathGraphics.fillStyle(canAfford ? 0x3498db : 0xe74c3c, 0.5);
        gameState.pathGraphics.fillCircle(destPx, destPy, 10);

        // Show hover info
        const hoverInfo = document.getElementById('hover-info');
        hoverInfo.className = 'move-mode';
        hoverInfo.innerHTML = `üèÉ Move ${distance} tiles ‚Üí <strong>${apCost} AP</strong> ${canAfford ? '‚úÖ' : '‚ùå'}`;
        hoverInfo.style.display = 'block';
    }

    function showAttackPreview(attacker, defender) {
        const weapon = WEAPONS[attacker.weaponId];
        const dist = Math.sqrt(Math.pow(defender.x - attacker.x, 2) + Math.pow(defender.y - attacker.y, 2));
        const inRange = dist <= weapon.range;
        const canAfford = attacker.ap >= weapon.ap;

        // Check Line of Sight (melee always has LOS)
        const isMelee = weapon.range <= 1;
        const hasLOS = isMelee || hasLineOfSight(attacker.x, attacker.y, defender.x, defender.y);

        // Show visual LOS indicator
        if (!isMelee && gameState.scene) {
            showLOSIndicator(gameState.scene, attacker.x, attacker.y, defender.x, defender.y, hasLOS);
        }

        const hoverInfo = document.getElementById('hover-info');
        hoverInfo.className = 'attack-mode';

        // Calculate expected damage
        const defenderArmor = ARMORS[defender.armorId];
        let expectedDR = defenderArmor.dr;
        if (weapon.ignoresArmor) {
            expectedDR = Math.floor((defenderArmor.energyDR || defenderArmor.dr * 0.5) * (1 - weapon.ignoresArmor));
        }
        const expectedDamage = Math.max(1, weapon.damage - expectedDR);

        // Build status line
        let statusLine = '';
        if (!hasLOS) {
            statusLine = 'üö´ NO LINE OF SIGHT';
        } else if (!inRange) {
            statusLine = '‚ùå Out of Range';
        } else if (!canAfford) {
            statusLine = '‚ùå Not enough AP';
        } else {
            statusLine = `‚úÖ ATTACK (${weapon.ap} AP)`;
        }

        hoverInfo.innerHTML = `
            ‚öîÔ∏è ${weapon.emoji} ${weapon.name} vs ${defender.origin.emoji} ${defender.name}<br>
            üí• ~${expectedDamage} dmg (${weapon.damage} - ${expectedDR} DR) | üìè ${dist.toFixed(1)}/${weapon.range}<br>
            ${hasLOS ? 'üëÅÔ∏è Clear LOS' : 'üö´ BLOCKED'} | ${statusLine}
        `;
        hoverInfo.style.display = 'block';
    }

    function clearPathPreview() {
        gameState.pathGraphics.clear();
        clearLOSIndicator();
    }

    function hideHoverInfo() {
        document.getElementById('hover-info').style.display = 'none';
        clearLOSIndicator();
    }

    function showTooltip(unit, pointer) {
        const tooltip = document.getElementById('char-tooltip');
        const weapon = WEAPONS[unit.weaponId];
        const armor = ARMORS[unit.armorId];
        const threatInfo = THREAT_LEVELS[unit.threatLevel];

        // Build immunities list based on origin
        let immunities = [];
        let vulnerabilities = [];
        if (!unit.origin.bleeds) immunities.push('ü©∏ Bleed');
        if (!unit.origin.burns) immunities.push('üî• Burn');
        if (unit.origin.freezes === false) immunities.push('üßä Freeze');
        if (unit.origin.stuns === false) immunities.push('üí´ Stun');
        if (unit.origin.poisonable === false) immunities.push('‚ò†Ô∏è Poison');
        if (unit.origin.empVulnerable) vulnerabilities.push('‚ö° EMP');

        // Build status effects display
        let effectsHtml = '';
        if (unit.statusEffects.length > 0) {
            effectsHtml = unit.statusEffects.map(e =>
                `<span class="tooltip-effect">${STATUS_EFFECTS[e.id].emoji} ${STATUS_EFFECTS[e.id].name} (${e.duration})</span>`
            ).join('');
        }

        tooltip.innerHTML = `
            <div class="tooltip-header">
                <div>
                    <div class="tooltip-name team-${unit.team}">${unit.origin.emoji} ${unit.name}</div>
                    <div class="tooltip-origin">${unit.origin.name} ‚Ä¢ ${threatInfo.emoji} ${threatInfo.name}</div>
                </div>
                <div class="tooltip-personality">${unit.personality.emoji} ${unit.personality.name}</div>
            </div>
            <div class="tooltip-stats">
                <div class="tooltip-stat"><div class="tooltip-stat-label">STR</div><div class="tooltip-stat-value">${unit.str}</div></div>
                <div class="tooltip-stat"><div class="tooltip-stat-label">AGL</div><div class="tooltip-stat-value">${unit.agl}</div></div>
                <div class="tooltip-stat"><div class="tooltip-stat-label">END</div><div class="tooltip-stat-value">${unit.end}</div></div>
                <div class="tooltip-stat"><div class="tooltip-stat-label">RSN</div><div class="tooltip-stat-value">${unit.rsn}</div></div>
                <div class="tooltip-stat"><div class="tooltip-stat-label">INT</div><div class="tooltip-stat-value">${unit.int}</div></div>
                <div class="tooltip-stat"><div class="tooltip-stat-label">PSY</div><div class="tooltip-stat-value">${unit.psy}</div></div>
            </div>
            <div style="margin-top: 8px; font-size: 11px;">
                ${weapon.emoji} <strong>${weapon.name}</strong> (${weapon.damage} dmg, ${weapon.range} range)<br>
                ${armor.emoji} <strong>${armor.name}</strong> (DR ${armor.dr})
            </div>
            ${unit.origin.powers ? `
                <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #333;">
                    <div style="color: #f39c12; font-size: 10px; font-weight: bold;">‚ö° POWERS</div>
                    <div style="font-size: 10px; color: #aaa;">${unit.origin.powers.join(' ‚Ä¢ ')}</div>
                    ${unit.origin.specialAction ? `<div style="font-size: 9px; color: #4ecdc4; margin-top: 2px;">üéØ ${unit.origin.specialAction}</div>` : ''}
                </div>
            ` : ''}
            ${immunities.length > 0 ? `<div class="tooltip-immunities">üõ°Ô∏è IMMUNE: ${immunities.join(' ')}</div>` : ''}
            ${vulnerabilities.length > 0 ? `<div style="color: #e74c3c; font-size: 10px; margin-top: 4px;">‚ö†Ô∏è WEAK TO: ${vulnerabilities.join(' ')}</div>` : ''}
            ${effectsHtml ? `<div class="tooltip-effects">${effectsHtml}</div>` : ''}
            ${getCareerSnippet(unit)}
        `;

        // Position tooltip
        tooltip.style.left = (pointer.x + 20) + 'px';
        tooltip.style.top = (pointer.y - 100) + 'px';
        tooltip.style.display = 'block';
    }

    function hideTooltip() {
        document.getElementById('char-tooltip').style.display = 'none';
    }

    function handleMoveClick(unit, targetX, targetY, scene) {
        const path = findPath(unit.x, unit.y, targetX, targetY);
        if (!path) return;

        const distance = path.length - 1;
        const apCost = Math.ceil(distance / 2);

        if (unit.ap < apCost) {
            addLog('‚ùå Not enough AP!', 'system');
            return;
        }

        clearPathPreview();
        hideHoverInfo();
        moveUnit(unit, targetX, targetY, path, apCost, scene, () => {
            updateDetailPanel(unit);
            updateUnitCards();
        });
    }

    function handleAttackClick(attacker, defender, scene) {
        const weapon = WEAPONS[attacker.weaponId];
        const dist = Math.sqrt(Math.pow(defender.x - attacker.x, 2) + Math.pow(defender.y - attacker.y, 2));

        clearPathPreview();
        hideHoverInfo();

        // In range? Attack directly
        if (dist <= weapon.range && attacker.ap >= weapon.ap) {
            attackUnit(attacker, defender, scene);
            return;
        }

        // Out of range - try to move closer then attack
        if (attacker.ap >= weapon.ap) {
            const targetTiles = [];
            for (let dy = -weapon.range; dy <= weapon.range; dy++) {
                for (let dx = -weapon.range; dx <= weapon.range; dx++) {
                    const tx = defender.x + dx;
                    const ty = defender.y + dy;
                    if (tx < 0 || tx >= GRID_SIZE || ty < 0 || ty >= GRID_SIZE) continue;
                    const d = Math.sqrt(dx*dx + dy*dy);
                    if (d > weapon.range || d === 0) continue;
                    const c = gameState.grid[ty][tx];
                    if (c.walkable && !c.unit) {
                        const path = findPath(attacker.x, attacker.y, tx, ty);
                        if (path) {
                            targetTiles.push({ x: tx, y: ty, path, dist: path.length - 1 });
                        }
                    }
                }
            }

            if (targetTiles.length > 0) {
                targetTiles.sort((a, b) => a.dist - b.dist);
                const best = targetTiles[0];
                const moveCost = Math.ceil(best.dist / 2);

                if (attacker.ap >= moveCost + weapon.ap) {
                    moveUnit(attacker, best.x, best.y, best.path, moveCost, scene, () => {
                        setTimeout(() => {
                            if (attacker.ap >= weapon.ap && defender.hp > 0) {
                                attackUnit(attacker, defender, scene);
                            }
                        }, 200);
                    });
                    return;
                }
            }
        }

        addLog('‚ùå Cannot reach target!', 'system');
    }

    // ============ MOVEMENT ============
    function moveUnit(unit, targetX, targetY, path, apCost, scene, callback) {
        gameState.animating = true;
        clearHighlights();
        gameState.grid[unit.y][unit.x].unit = null;

        let pathIndex = 1;
        const moveNext = () => {
            if (pathIndex >= path.length) {
                unit.ap -= apCost;
                unit.x = targetX;
                unit.y = targetY;
                gameState.grid[targetY][targetX].unit = unit;
                addLog(`üèÉ ${unit.origin.emoji} ${unit.name} moves (${apCost} AP)`, 'move');
                gameState.animating = false;
                updateUnitCards();
                refreshVisibility(); // Update fog of war after move
                if (callback) callback();
                return;
            }

            const next = path[pathIndex];
            const px = gameState.offsetX + next.x * TILE_SIZE + TILE_SIZE / 2;
            const py = gameState.offsetY + next.y * TILE_SIZE + TILE_SIZE / 2;

            scene.tweens.add({
                targets: unit.sprite,
                x: px, y: py,
                duration: 80,
                onUpdate: () => {
                    unit.hpBg.setPosition(unit.sprite.x, unit.sprite.y - 22);
                    unit.hpBar.setPosition(unit.sprite.x, unit.sprite.y - 22);
                    unit.nameText.setPosition(unit.sprite.x, unit.sprite.y + 22);
                    unit.effectsContainer.setPosition(unit.sprite.x, unit.sprite.y - 32);
                },
                onComplete: () => { pathIndex++; moveNext(); }
            });
        };
        moveNext();
    }

    // ============ KNOCKBACK SYSTEM ============
    function applyKnockback(attacker, defender, knockbackTiles, scene) {
        if (!knockbackTiles || knockbackTiles <= 0 || defender.hp <= 0) return;

        // Calculate direction from attacker to defender
        const dx = defender.x - attacker.x;
        const dy = defender.y - attacker.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist === 0) return;

        // Normalize direction
        const dirX = Math.round(dx / dist);
        const dirY = Math.round(dy / dist);

        let finalX = defender.x;
        let finalY = defender.y;
        let tilesKnocked = 0;
        let hitWall = false;
        let wallDamage = 0;

        // Check each tile in knockback path
        for (let i = 1; i <= knockbackTiles; i++) {
            const newX = defender.x + (dirX * i);
            const newY = defender.y + (dirY * i);

            // Check bounds
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                hitWall = true;
                wallDamage = 10 * (knockbackTiles - tilesKnocked); // Damage for hitting map edge
                break;
            }

            const cell = gameState.grid[newY][newX];

            // Check for obstacles (walls)
            if (cell.obstacle) {
                hitWall = true;
                wallDamage = 15 * (knockbackTiles - tilesKnocked); // Extra damage for hitting wall
                addLog(`  üí• ${defender.name} SLAMS into ${cell.obstacle.type}!`, 'effect');
                break;
            }

            // Check for other units (can't knock through them)
            if (cell.unit && cell.unit !== defender) {
                hitWall = true;
                wallDamage = 10;
                addLog(`  üí• ${defender.name} crashes into ${cell.unit.name}!`, 'effect');
                // Also damage the unit they hit
                cell.unit.hp -= 5;
                updateUnitVisuals(cell.unit);
                break;
            }

            // Valid tile - update position
            finalX = newX;
            finalY = newY;
            tilesKnocked++;
        }

        // Apply wall impact damage
        if (hitWall && wallDamage > 0) {
            defender.hp -= wallDamage;
            addLog(`  üß± Wall impact deals ${wallDamage} damage!`, 'damage');
            updateUnitVisuals(defender);

            // Check if this killed them
            if (defender.hp <= 0) {
                killUnit(defender, scene, 'WALL_IMPACT');
                addLog(`üíÄ ${defender.name} is KILLED by wall impact!`, 'kill');
                checkVictory();
                return;
            }
        }

        // Move the defender if they were knocked back
        if (tilesKnocked > 0) {
            // Update grid
            gameState.grid[defender.y][defender.x].unit = null;
            defender.x = finalX;
            defender.y = finalY;
            gameState.grid[finalY][finalX].unit = defender;

            // Animate the knockback
            const pixelX = gameState.offsetX + finalX * TILE_SIZE + TILE_SIZE / 2;
            const pixelY = gameState.offsetY + finalY * TILE_SIZE + TILE_SIZE / 2;

            scene.tweens.add({
                targets: [defender.sprite, defender.hpBar, defender.hpBarBg, defender.nameText, defender.effectsContainer],
                x: pixelX,
                y: function(target) {
                    if (target === defender.nameText) return pixelY + 22;
                    if (target === defender.effectsContainer) return pixelY - 32;
                    return pixelY;
                },
                duration: 150,
                ease: 'Power2'
            });

            addLog(`  ‚¨ÖÔ∏è ${defender.name} knocked back ${tilesKnocked} tile${tilesKnocked > 1 ? 's' : ''}!`, 'effect');
        }
    }

    // ============ COMBAT ============
    function attackUnit(attacker, defender, scene) {
        const weapon = WEAPONS[attacker.weaponId];
        if (attacker.ap < weapon.ap) return;

        // Check Line of Sight (melee always has LOS)
        if (weapon.range > 1) {
            const losCheck = checkLOS(attacker, defender);
            if (losCheck.blocked) {
                addLog(`‚ùå NO LINE OF SIGHT! ${losCheck.reason} blocks shot at (${losCheck.x}, ${losCheck.y})`, 'system');
                return;
            }
        }

        attacker.ap -= weapon.ap;
        gameState.animating = true;
        clearHighlights();

        // Emit sound from attack location
        emitSound(attacker.x, attacker.y, weapon.sound, attacker.name, attacker.team);

        // Track shots fired
        gameState.combatStats.shotsFired[attacker.team]++;

        // Initialize unit tracking if needed
        if (!gameState.combatStats.damageByUnit[attacker.name]) {
            gameState.combatStats.damageByUnit[attacker.name] = { dealt: 0, taken: 0, kills: 0, shots: 0, hits: 0, meleeDamage: 0, rangedDamage: 0, rangedShots: 0, rangedHits: 0, team: attacker.team };
        }
        if (!gameState.combatStats.damageByUnit[defender.name]) {
            gameState.combatStats.damageByUnit[defender.name] = { dealt: 0, taken: 0, kills: 0, shots: 0, hits: 0, meleeDamage: 0, rangedDamage: 0, rangedShots: 0, rangedHits: 0, team: defender.team };
        }
        gameState.combatStats.damageByUnit[attacker.name].shots++;
        const isMelee = weapon.range <= 1;
        if (!isMelee) {
            gameState.combatStats.damageByUnit[attacker.name].rangedShots++;
        }

        fireVisualEffect(scene, attacker, defender, weapon, () => {
            const result = resolveAttack(attacker, defender);
            const verbs = DAMAGE_VERBS[weapon.damageType] || DAMAGE_VERBS.GUNFIRE;
            const ctx = result.context;

            if (result.hit) {
                defender.hp -= result.damage;
                const overkill = defender.hp < 0 ? Math.abs(defender.hp) : 0;
                updateUnitVisuals(defender);

                // Track comprehensive stats
                gameState.combatStats.totalDamageDealt[attacker.team] += result.damage;
                gameState.combatStats.armorAbsorbed[defender.team] += result.dr;
                gameState.combatStats.damageByUnit[attacker.name].dealt += result.damage;
                gameState.combatStats.damageByUnit[attacker.name].hits++;
                gameState.combatStats.damageByUnit[defender.name].taken += result.damage;

                // Track melee vs ranged damage
                if (isMelee) {
                    gameState.combatStats.meleeDamage[attacker.team] += result.damage;
                    gameState.combatStats.damageByUnit[attacker.name].meleeDamage += result.damage;
                } else {
                    gameState.combatStats.rangedDamage[attacker.team] += result.damage;
                    gameState.combatStats.damageByUnit[attacker.name].rangedDamage += result.damage;
                    gameState.combatStats.damageByUnit[attacker.name].rangedHits++;
                }

                // Track most damage taken
                if (gameState.combatStats.damageByUnit[defender.name].taken > gameState.combatStats.mostDamageTaken.damage) {
                    gameState.combatStats.mostDamageTaken = { unit: defender.name, damage: gameState.combatStats.damageByUnit[defender.name].taken };
                }

                // Track by weapon
                if (!gameState.combatStats.damageByWeapon[attacker.weaponId]) {
                    gameState.combatStats.damageByWeapon[attacker.weaponId] = { damage: 0, shots: 0, hits: 0, kills: 0 };
                }
                gameState.combatStats.damageByWeapon[attacker.weaponId].damage += result.damage;
                gameState.combatStats.damageByWeapon[attacker.weaponId].hits++;

                // Track by result type
                if (result.result === 'CRIT') gameState.combatStats.criticalHits[attacker.team]++;
                else if (result.result === 'GRAZE') gameState.combatStats.grazes[attacker.team]++;
                else gameState.combatStats.hits[attacker.team]++;

                // Track overkill
                if (overkill > 0) {
                    gameState.combatStats.overkillDamage[attacker.team] += overkill;
                }

                // ========== RICH COMBAT FEEDBACK ==========
                const verb = result.result === 'CRIT' ? verbs.crit : (result.result === 'GRAZE' ? verbs.graze : verbs.hit);

                // Main attack line with flair
                let attackLine = `${weapon.emoji} ${attacker.name} ${verb} ${defender.origin.emoji} ${defender.name}`;
                if (result.result === 'CRIT') attackLine += ' üí•üí•';
                addLog(attackLine, 'attack');

                // Roll breakdown (dice transparency)
                let rollInfo = `  üé≤ Roll: ${ctx.roll}`;
                if (ctx.agilityBonus !== 0) rollInfo += ` ${ctx.agilityBonus >= 0 ? '+' : ''}${ctx.agilityBonus} AGL`;
                if (ctx.weaponAccuracy !== 0) rollInfo += ` ${ctx.weaponAccuracy >= 0 ? '+' : ''}${ctx.weaponAccuracy} ACC`;
                if (ctx.closeRangeBonus > 0) rollInfo += ` +${ctx.closeRangeBonus} CLOSE`;
                if (ctx.coverBonus > 0) rollInfo += ` -${ctx.coverBonus} COVER`;
                rollInfo += ` = ${ctx.finalRoll}`;
                addLog(rollInfo, 'system');

                // Damage breakdown with context
                let damageDetail = `  üí• ${result.damage} damage`;
                if (result.strBonus > 0) damageDetail += ` (+${result.strBonus} STR)`;
                if (result.mult === 1.5) damageDetail += ' [√ó1.5 CRIT]';
                else if (result.mult === 0.5) damageDetail += ' [√ó0.5 GRAZE]';
                addLog(damageDetail, 'damage');

                // Armor interaction feedback
                if (result.dr > 0) {
                    if (ctx.energyBypass) {
                        addLog(`  ‚ö° Energy bypasses ${ctx.armorName}! (${result.dr} DR)`, 'effect');
                    } else if (ctx.armorPierced) {
                        addLog(`  üî© AP rounds punch through ${ctx.armorName}!`, 'effect');
                    } else {
                        addLog(`  üõ°Ô∏è ${ctx.armorName} absorbs ${result.dr} damage`, 'system');
                    }
                }

                // EMP bonus feedback
                if (result.empBonus > 0) {
                    addLog(`  ‚ö° EMP SURGE! +${result.empBonus} vs ${defender.origin.name}!`, 'effect');
                }

                // Overkill feedback
                if (overkill > 0 && defender.hp <= 0) {
                    if (overkill > 30) {
                        addLog(`  üíÄ OBLITERATED! (${overkill} overkill)`, 'kill');
                    } else if (overkill > 15) {
                        addLog(`  üíÄ DEVASTATING! (${overkill} overkill)`, 'kill');
                    } else {
                        addLog(`  üíÄ Overkill: ${overkill}`, 'damage');
                    }
                }

                // Apply status effects
                applyStatusEffect(attacker, defender, weapon, result);

                // Check for injury on CRIT or overkill
                if (result.result === 'CRIT' || overkill > 0) {
                    const injury = rollInjury(defender, result.result === 'CRIT', overkill);
                    if (injury && injury.severity !== 'LUCKY' && injury.severity !== 'LIGHT') {
                        addLog(`  ü©π INJURY: ${injury.description}`, 'injury');
                        gameState.combatStats.injuriesInflicted.push({
                            victim: defender.name,
                            injury: injury.description,
                            attacker: attacker.name,
                            turn: gameState.turn
                        });
                    }
                }

                // Apply knockback if weapon has it and defender is still alive
                if (weapon.knockback && defender.hp > 0) {
                    applyKnockback(attacker, defender, weapon.knockback, scene);
                }

                if (defender.hp <= 0) {
                    // Track kill stats
                    gameState.combatStats.totalKills[attacker.team]++;
                    gameState.combatStats.damageByUnit[attacker.name].kills++;
                    if (!gameState.combatStats.damageByWeapon[attacker.weaponId]) {
                        gameState.combatStats.damageByWeapon[attacker.weaponId] = { damage: 0, shots: 0, hits: 0, kills: 0 };
                    }
                    gameState.combatStats.damageByWeapon[attacker.weaponId].kills++;

                    // Track kill streak
                    if (!gameState.combatStats.currentStreaks[attacker.name]) {
                        gameState.combatStats.currentStreaks[attacker.name] = 0;
                    }
                    gameState.combatStats.currentStreaks[attacker.name]++;
                    if (gameState.combatStats.currentStreaks[attacker.name] > gameState.combatStats.longestKillstreak.streak) {
                        gameState.combatStats.longestKillstreak = {
                            unit: attacker.name,
                            streak: gameState.combatStats.currentStreaks[attacker.name]
                        };
                    }

                    // Log the kill for timeline
                    const killEntry = {
                        turn: gameState.turn,
                        killer: attacker.name,
                        killerOrigin: attacker.origin.emoji,
                        killerTeam: attacker.team,
                        victim: defender.name,
                        victimOrigin: defender.origin.emoji,
                        victimTeam: defender.team,
                        weapon: weapon.name,
                        overkill: overkill
                    };
                    gameState.combatStats.killLog.push(killEntry);

                    // Track first blood
                    if (!gameState.combatStats.firstBlood) {
                        gameState.combatStats.firstBlood = killEntry;
                    }
                    // Always update last kill
                    gameState.combatStats.lastKill = killEntry;

                    gameState.combatStats.turnDeaths.push({
                        turn: gameState.turn,
                        unit: defender.name,
                        team: defender.team
                    });

                    killUnit(defender, scene, weapon.damageType);
                    checkVictory();
                } else {
                    addLog(`  ‚ù§Ô∏è ${defender.name}: ${defender.hp}/${defender.maxHp} HP remaining`, 'system');
                }
            } else {
                // ========== MISS FEEDBACK ==========
                gameState.combatStats.misses[attacker.team]++;

                if (result.context && result.context.coverSaved) {
                    addLog(`${weapon.emoji} ${attacker.name} fires at ${defender.name}...`, 'attack');
                    addLog(`  ü™® COVER SAVES! Shot blocked by cover!`, 'effect');
                    addLog(`  üé≤ Roll: ${result.context.roll} - ${result.context.coverBonus} cover = ${result.context.finalRoll}`, 'system');
                } else {
                    addLog(`${weapon.emoji} ${attacker.name} ${verbs.miss} ${defender.name}!`, 'attack');
                    if (result.context) {
                        addLog(`  üé≤ Roll: ${result.context.roll} ‚Üí ${result.context.finalRoll} (needed 40+)`, 'system');
                    }
                }
            }

            gameState.animating = false;
            updateDetailPanel(attacker);
            updateUnitCards();
        });
    }

    function resolveAttack(attacker, defender) {
        const weapon = WEAPONS[attacker.weaponId];
        const armor = ARMORS[defender.armorId];
        const dist = Math.sqrt(Math.pow(defender.x - attacker.x, 2) + Math.pow(defender.y - attacker.y, 2));

        // Build context for combat feedback
        const context = {
            roll: 0,
            finalRoll: 0,
            coverBonus: 0,
            agilityBonus: 0,
            weaponAccuracy: 0,
            closeRangeBonus: 0,
            armorPierced: false,
            energyBypass: false,
            coverSaved: false,
            armorName: armor.name,
            distance: dist.toFixed(1)
        };

        // Calculate accuracy bonus
        context.agilityBonus = Math.floor((attacker.agl - 30) / 10) * 5;
        context.weaponAccuracy = (weapon.accuracy || 0) * 5;
        let bonus = context.agilityBonus + context.weaponAccuracy;

        if (weapon.closeBonus && dist <= 2) {
            context.closeRangeBonus = weapon.closeBonus * 5;
            bonus += context.closeRangeBonus;
        }

        // Cover penalty
        const defCell = gameState.grid[defender.y][defender.x];
        context.coverBonus = defCell.cover === 2 ? 15 : (defCell.cover === 1 ? 8 : 0);
        const coverPen = context.coverBonus;

        // Status effect modifiers
        let attackerBonus = 0;
        let defenderPenalty = 0;
        attacker.statusEffects.forEach(e => {
            const effect = STATUS_EFFECTS[e.id];
            if (effect.accuracyBonus) attackerBonus += effect.accuracyBonus;
            if (effect.accuracyPenalty) attackerBonus -= effect.accuracyPenalty;
        });
        defender.statusEffects.forEach(e => {
            const effect = STATUS_EFFECTS[e.id];
            if (effect.accuracyPenalty) defenderPenalty += effect.accuracyPenalty / 2;
        });

        context.roll = Math.floor(Math.random() * 100) + 1;
        context.finalRoll = context.roll + bonus - coverPen + attackerBonus + defenderPenalty;

        let result, mult;
        if (context.finalRoll < 40) { result = 'MISS'; mult = 0; }
        else if (context.finalRoll < 70) { result = 'GRAZE'; mult = 0.5; }
        else if (context.finalRoll < 95) { result = 'HIT'; mult = 1.0; }
        else { result = 'CRIT'; mult = 1.5; }

        // Check if cover caused the miss
        if (mult === 0 && context.roll + bonus >= 40 && coverPen > 0) {
            context.coverSaved = true;
            gameState.combatStats.coverSaves++;
        }

        if (mult === 0) return { hit: false, result, context };

        // Calculate damage
        let dmg = weapon.damage;
        let strBonus = 0;
        if (weapon.strBonus) {
            strBonus = Math.floor(attacker.str / 10);
            dmg += strBonus;
        }
        dmg = Math.floor(dmg * mult);

        // EMP bonus against tech/constructs
        let empBonus = 0;
        if (weapon.empDamageBonus && defender.origin.empVulnerable) {
            empBonus = weapon.empDamageBonus;
            dmg += empBonus;
        }

        // Calculate DR
        let dr = armor.dr;
        let drBeforePen = dr;
        if (weapon.ignoresArmor) {
            context.energyBypass = true;
            dr = armor.energyDR || Math.floor(armor.dr * 0.5);
            dr = Math.floor(dr * (1 - weapon.ignoresArmor));
        } else if (weapon.drPen > 0) {
            context.armorPierced = weapon.drPen >= drBeforePen;
            dr = Math.max(0, dr - (weapon.drPen || 0));
        }

        const finalDamage = Math.max(1, dmg - dr);
        context.damageBlocked = Math.min(dmg - 1, dr);

        return {
            hit: true,
            damage: finalDamage,
            rawDamage: dmg,
            dr,
            result,
            empBonus,
            strBonus,
            mult,
            context
        };
    }

    function applyStatusEffect(attacker, defender, weapon, attackResult) {
        if (!weapon.canCauseEffect) return;

        const effectId = weapon.canCauseEffect;
        const effect = STATUS_EFFECTS[effectId];

        // Check if defender is immune based on origin
        if (effectId === 'bleeding' && !defender.origin.bleeds) {
            if (defender.origin.id === 'construct') {
                addLog(`‚öôÔ∏è ${defender.name} doesn't bleed - sparks fly instead!`, 'effect');
            }
            return;
        }
        if (effectId === 'burning' && !defender.origin.burns) return;
        if (effectId === 'frozen' && !defender.origin.freezes) return;
        if (effectId === 'poisoned' && !defender.origin.poisonable) return;
        if (effectId === 'emp' && !defender.origin.empVulnerable) {
            addLog(`‚ö° ${defender.name} is not affected by EMP!`, 'effect');
            return;
        }

        // Apply effect on CRIT or 30% chance on HIT
        const applyChance = attackResult.result === 'CRIT' ? 1.0 : 0.3;
        if (Math.random() < applyChance) {
            // Check if already has this effect
            const existing = defender.statusEffects.find(e => e.id === effectId);
            if (existing && !effect.stackable) {
                existing.duration = effect.duration; // Refresh duration
            } else {
                defender.statusEffects.push({ id: effectId, duration: effect.duration });
            }
            addLog(`${effect.emoji} ${defender.name} is ${effect.name.toLowerCase()}!`, 'effect');
            updateUnitCards();
        }
    }

    function rollInjury(defender, isCrit, overkill) {
        // Don't roll injuries for constructs/cosmic beings (different damage system)
        if (defender.origin.id === 'construct' || defender.origin.id === 'cosmic') {
            return null;
        }

        // Roll d100
        let roll = Math.floor(Math.random() * 100) + 1;

        // Modify roll based on severity
        if (isCrit) roll -= 10; // More severe
        if (overkill > 20) roll -= 20; // Massive overkill = worse injury
        else if (overkill > 10) roll -= 10;

        roll = Math.max(1, Math.min(100, roll));

        // Find matching injury
        for (const injury of INJURY_TABLE) {
            if (roll >= injury.range[0] && roll <= injury.range[1]) {
                return injury;
            }
        }
        return INJURY_TABLE[INJURY_TABLE.length - 1]; // Default to lucky
    }

    function killUnit(unit, scene, damageType) {
        gameState.grid[unit.y][unit.x].unit = null;
        unit.hp = 0;

        // Death visual based on origin
        const deathType = unit.origin.deathVisual;

        if (deathType === 'shutdown') {
            // Construct shutdown - sparks and power down
            addLog(`‚ö° ${unit.name} powers down with a shower of sparks!`, 'kill');
            scene.tweens.add({
                targets: [unit.sprite],
                alpha: 0,
                duration: 800,
                ease: 'Steps',
                easeParams: [4], // Flicker effect
                onComplete: () => destroyUnit(unit)
            });
        } else if (deathType === 'fade') {
            // Mystic fade
            addLog(`‚ú® ${unit.name} fades into nothingness!`, 'kill');
            scene.tweens.add({
                targets: [unit.sprite, unit.hpBar, unit.hpBg, unit.nameText],
                alpha: 0,
                scale: 1.5,
                duration: 600,
                onComplete: () => destroyUnit(unit)
            });
        } else if (deathType === 'dissolve') {
            // Alien dissolve
            addLog(`üß™ ${unit.name} dissolves into alien ichor!`, 'kill');
            scene.tweens.add({
                targets: [unit.sprite, unit.hpBar, unit.hpBg, unit.nameText],
                alpha: 0,
                scaleY: 0,
                duration: 500,
                onComplete: () => destroyUnit(unit)
            });
        } else {
            // Standard collapse
            scene.tweens.add({
                targets: [unit.sprite, unit.hpBar, unit.hpBg, unit.nameText],
                alpha: 0,
                duration: 500,
                onComplete: () => destroyUnit(unit)
            });
        }
    }

    function destroyUnit(unit) {
        unit.sprite.destroy();
        unit.hpBar.destroy();
        unit.hpBg.destroy();
        unit.nameText.destroy();
        unit.effectsContainer.destroy();
        const idx = gameState.units.indexOf(unit);
        if (idx > -1) gameState.units.splice(idx, 1);
        updateUnitCards();
    }

    // ============ VISUAL EFFECTS ============
    function fireVisualEffect(scene, attacker, defender, weapon, callback) {
        const v = weapon.visual;
        const sx = gameState.offsetX + attacker.x * TILE_SIZE + TILE_SIZE / 2;
        const sy = gameState.offsetY + attacker.y * TILE_SIZE + TILE_SIZE / 2;
        const ex = gameState.offsetX + defender.x * TILE_SIZE + TILE_SIZE / 2;
        const ey = gameState.offsetY + defender.y * TILE_SIZE + TILE_SIZE / 2;

        if (v.type === 'beam') {
            const angle = Math.atan2(ey - sy, ex - sx);
            const length = Math.sqrt((ex-sx)**2 + (ey-sy)**2);
            const beam = scene.add.rectangle(sx, sy, 0, 6, v.color).setOrigin(0, 0.5).setRotation(angle).setDepth(100);
            scene.tweens.add({ targets: beam, width: length, duration: 100,
                onComplete: () => scene.tweens.add({ targets: beam, alpha: 0, duration: 150, onComplete: () => { beam.destroy(); callback(); } })
            });
        } else if (v.type === 'cone') {
            const angle = Math.atan2(ey - sy, ex - sx);
            const length = Math.min(Math.sqrt((ex-sx)**2 + (ey-sy)**2), 120);
            const spreadRad = ((v.spread || 30) / 2) * Math.PI / 180;
            const g = scene.add.graphics().setDepth(100);
            g.fillStyle(v.color, 0.5);
            g.beginPath(); g.moveTo(sx, sy);
            g.lineTo(sx + Math.cos(angle - spreadRad) * length, sy + Math.sin(angle - spreadRad) * length);
            g.lineTo(sx + Math.cos(angle + spreadRad) * length, sy + Math.sin(angle + spreadRad) * length);
            g.closePath(); g.fillPath();
            scene.tweens.add({ targets: g, alpha: 0, duration: 300, onComplete: () => { g.destroy(); callback(); } });
        } else if (v.type === 'melee') {
            const angle = Math.atan2(ey - sy, ex - sx);
            const slash = scene.add.rectangle((sx+ex)/2, (sy+ey)/2, 40, 6, v.color).setRotation(angle).setDepth(100).setAlpha(0).setScale(0.5, 1);
            scene.tweens.add({ targets: slash, alpha: 1, scaleX: 1.5, duration: 100, yoyo: true, onComplete: () => { slash.destroy(); callback(); } });
        } else {
            const proj = scene.add.circle(sx, sy, 5, v.color).setDepth(100);
            scene.tweens.add({ targets: proj, x: ex, y: ey, duration: 200, onComplete: () => {
                const flash = scene.add.circle(ex, ey, 15, v.color).setAlpha(0.8);
                scene.tweens.add({ targets: flash, alpha: 0, scale: 2, duration: 150, onComplete: () => { flash.destroy(); proj.destroy(); callback(); } });
            }});
        }
    }

    // ============ PATHFINDING ============
    function findPath(sx, sy, ex, ey) {
        const openSet = [{ x: sx, y: sy, f: 0, g: 0 }];
        const closedSet = new Set();
        const cameFrom = {};
        const gScore = { [`${sx},${sy}`]: 0 };

        while (openSet.length > 0) {
            openSet.sort((a, b) => a.f - b.f);
            const current = openSet.shift();
            const key = `${current.x},${current.y}`;

            if (current.x === ex && current.y === ey) {
                const path = [{ x: ex, y: ey }];
                let k = key;
                while (cameFrom[k]) { path.unshift(cameFrom[k]); k = `${cameFrom[k].x},${cameFrom[k].y}`; }
                return path;
            }

            closedSet.add(key);

            for (const [dx, dy] of [[0,-1],[0,1],[-1,0],[1,0]]) {
                const nx = current.x + dx, ny = current.y + dy;
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
                const cell = gameState.grid[ny][nx];
                if (!cell.walkable || (cell.unit && !(nx === ex && ny === ey))) continue;

                const nKey = `${nx},${ny}`;
                if (closedSet.has(nKey)) continue;

                const tentG = gScore[key] + 1;
                if (!gScore[nKey] || tentG < gScore[nKey]) {
                    cameFrom[nKey] = { x: current.x, y: current.y };
                    gScore[nKey] = tentG;
                    const h = Math.abs(nx - ex) + Math.abs(ny - ey);
                    if (!openSet.some(n => n.x === nx && n.y === ny)) {
                        openSet.push({ x: nx, y: ny, f: tentG + h, g: tentG });
                    }
                }
            }
        }
        return null;
    }

    // ============ LINE OF SIGHT (LOS) ============
    // Uses Bresenham's line algorithm to check if there's a clear line between two points
    function hasLineOfSight(x1, y1, x2, y2) {
        // Same cell - always visible
        if (x1 === x2 && y1 === y2) return true;

        const dx = Math.abs(x2 - x1);
        const dy = Math.abs(y2 - y1);
        const sx = x1 < x2 ? 1 : -1;
        const sy = y1 < y2 ? 1 : -1;
        let err = dx - dy;

        let x = x1;
        let y = y1;

        while (true) {
            // Check if we reached the target
            if (x === x2 && y === y2) return true;

            // Check for LOS blockers (walls block, cover doesn't fully block)
            const cell = gameState.grid[y]?.[x];
            if (cell) {
                // Walls always block LOS
                if (cell.type === 'wall') {
                    // Unless it's the start or end cell
                    if (!(x === x1 && y === y1) && !(x === x2 && y === y2)) {
                        return false;
                    }
                }
            }

            const e2 = 2 * err;
            if (e2 > -dy) {
                err -= dy;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                y += sy;
            }

            // Safety check for infinite loops
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
        }
    }

    // Check if attacker can see target (returns reason if blocked)
    function checkLOS(attacker, target) {
        const hasLOS = hasLineOfSight(attacker.x, attacker.y, target.x, target.y);

        if (!hasLOS) {
            // Find what's blocking
            const dx = Math.abs(target.x - attacker.x);
            const dy = Math.abs(target.y - attacker.y);
            const sx = attacker.x < target.x ? 1 : -1;
            const sy = attacker.y < target.y ? 1 : -1;
            let err = dx - dy;
            let x = attacker.x;
            let y = attacker.y;

            while (!(x === target.x && y === target.y)) {
                const cell = gameState.grid[y]?.[x];
                if (cell && cell.type === 'wall' && !(x === attacker.x && y === attacker.y)) {
                    return { blocked: true, reason: 'WALL', x, y };
                }

                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x += sx; }
                if (e2 < dx) { err += dx; y += sy; }
            }
        }

        return { blocked: false };
    }

    // Visual indicator for LOS
    function showLOSIndicator(scene, fromX, fromY, toX, toY, hasLOS) {
        if (!gameState.losGraphics) {
            gameState.losGraphics = scene.add.graphics();
        }
        gameState.losGraphics.clear();

        const startX = gameState.offsetX + fromX * TILE_SIZE + TILE_SIZE / 2;
        const startY = gameState.offsetY + fromY * TILE_SIZE + TILE_SIZE / 2;
        const endX = gameState.offsetX + toX * TILE_SIZE + TILE_SIZE / 2;
        const endY = gameState.offsetY + toY * TILE_SIZE + TILE_SIZE / 2;

        if (hasLOS) {
            // Green dashed line for clear LOS
            gameState.losGraphics.lineStyle(2, 0x00ff00, 0.6);
        } else {
            // Red crossed line for blocked LOS
            gameState.losGraphics.lineStyle(3, 0xff0000, 0.8);
        }

        gameState.losGraphics.beginPath();
        gameState.losGraphics.moveTo(startX, startY);
        gameState.losGraphics.lineTo(endX, endY);
        gameState.losGraphics.strokePath();

        if (!hasLOS) {
            // Draw X at midpoint
            const midX = (startX + endX) / 2;
            const midY = (startY + endY) / 2;
            gameState.losGraphics.lineStyle(4, 0xff0000, 1);
            gameState.losGraphics.beginPath();
            gameState.losGraphics.moveTo(midX - 8, midY - 8);
            gameState.losGraphics.lineTo(midX + 8, midY + 8);
            gameState.losGraphics.moveTo(midX + 8, midY - 8);
            gameState.losGraphics.lineTo(midX - 8, midY + 8);
            gameState.losGraphics.strokePath();
        }
    }

    function clearLOSIndicator() {
        if (gameState.losGraphics) {
            gameState.losGraphics.clear();
        }
    }

    // ============ FOG OF WAR ============
    // Hide enemies that no friendly unit can see
    function updateFogOfWar() {
        const friendlyTeam = gameState.playerTeam; // Player team
        const enemyTeam = friendlyTeam === 'a' ? 'b' : 'a';

        const friendlyUnits = gameState.units.filter(u => u.team === friendlyTeam && u.hp > 0);
        const enemyUnits = gameState.units.filter(u => u.team === enemyTeam && u.hp > 0);

        // Check visibility for each enemy
        enemyUnits.forEach(enemy => {
            let isVisible = false;

            // Check if ANY friendly unit can see this enemy
            for (const friendly of friendlyUnits) {
                // Check distance (vision range)
                const dist = Math.sqrt((enemy.x - friendly.x)**2 + (enemy.y - friendly.y)**2);
                const visionRange = 10; // Base vision range

                if (dist <= visionRange && hasLineOfSight(friendly.x, friendly.y, enemy.x, enemy.y)) {
                    isVisible = true;
                    break;
                }
            }

            // Update enemy visibility
            enemy.visible = isVisible;
            if (enemy.sprite) {
                enemy.sprite.setAlpha(isVisible ? 1 : 0);
                enemy.hpBg.setAlpha(isVisible ? 1 : 0);
                enemy.hpBar.setAlpha(isVisible ? 1 : 0);
                enemy.nameText.setAlpha(isVisible ? 1 : 0);
                enemy.effectsContainer.setAlpha(isVisible ? 1 : 0);
            }
        });
    }

    // Call this when units move or at start of turn
    function refreshVisibility() {
        updateFogOfWar();
        updateUnitCards(); // Update bottom bar to reflect visibility
    }

    // ============ SOUND SYSTEM ============
    // Visual and detection for sound propagation

    function emitSound(x, y, soundData, sourceName, sourceTeam) {
        if (!soundData) return;

        const decibels = soundData.decibels;
        const baseRange = soundData.baseRange;

        // Scale range to grid (base range is in real units, divide for tile scale)
        const tileRange = Math.min(Math.ceil(baseRange / 5), 15); // Max 15 tiles for visual

        // Show visual effect
        showSoundRing(x, y, tileRange, decibels);

        // Check which units can hear this sound
        const listeners = gameState.units.filter(u => {
            if (u.hp <= 0) return false;
            if (u.team === sourceTeam) return false; // Same team already knows
            const dist = Math.sqrt((u.x - x) ** 2 + (u.y - y) ** 2);
            return dist <= tileRange;
        });

        // Log who heard it - BUNDLED into one notification
        if (listeners.length > 0) {
            const hearingEmoji = decibels >= 100 ? 'üí•' : decibels >= 60 ? 'üîä' : 'üëÇ';
            const loudness = decibels >= 140 ? 'GUNFIRE' : decibels >= 100 ? 'LOUD NOISE' : decibels >= 60 ? 'noise' : 'faint sound';

            // Direction arrows
            const getDirectionArrow = (dx, dy) => {
                if (Math.abs(dx) > Math.abs(dy)) {
                    return dx > 0 ? '‚û°Ô∏è' : '‚¨ÖÔ∏è';  // East/West
                } else {
                    return dy > 0 ? '‚¨áÔ∏è' : '‚¨ÜÔ∏è';  // South/North
                }
            };

            // Group listeners by direction they heard from
            const byDirection = {};
            listeners.forEach(unit => {
                const dx = x - unit.x;
                const dy = y - unit.y;
                const arrow = getDirectionArrow(dx, dy);

                // Add "heard" indicator to unit
                if (!unit.heardSounds) unit.heardSounds = [];
                unit.heardSounds.push({
                    x, y, decibels, source: sourceName, turn: gameState.turn
                });

                if (!byDirection[arrow]) byDirection[arrow] = [];
                byDirection[arrow].push(unit.codename || unit.name);
            });

            // Build bundled notification
            const parts = Object.entries(byDirection).map(([arrow, names]) => {
                return `${names.join(', ')} üëÇ${arrow}`;
            });

            addLog(`  ${hearingEmoji} HEARD ${loudness}: ${parts.join(' | ')}`, 'effect');
        }
    }

    function showSoundRing(x, y, range, decibels) {
        const scene = gameState.scene;
        if (!scene) return;

        const px = gameState.offsetX + x * TILE_SIZE + TILE_SIZE / 2;
        const py = gameState.offsetY + y * TILE_SIZE + TILE_SIZE / 2;

        // Color based on decibels
        let ringColor = 0x888888; // Quiet
        if (decibels >= 140) ringColor = 0xff4444; // Gunfire - red
        else if (decibels >= 100) ringColor = 0xff8800; // Loud - orange
        else if (decibels >= 60) ringColor = 0xffff00; // Medium - yellow

        // Create expanding ring effect
        const ring = scene.add.circle(px, py, 10, ringColor, 0);
        ring.setStrokeStyle(2, ringColor, 0.8);
        ring.setDepth(1000);

        // Animate expansion
        scene.tweens.add({
            targets: ring,
            radius: range * TILE_SIZE,
            alpha: 0,
            duration: 600,
            ease: 'Power2',
            onComplete: () => ring.destroy()
        });

        // For loud sounds, add secondary ring
        if (decibels >= 100) {
            const ring2 = scene.add.circle(px, py, 10, ringColor, 0);
            ring2.setStrokeStyle(3, ringColor, 0.5);
            ring2.setDepth(1000);

            scene.tweens.add({
                targets: ring2,
                radius: range * TILE_SIZE * 0.7,
                alpha: 0,
                duration: 400,
                ease: 'Power2',
                onComplete: () => ring2.destroy()
            });
        }
    }

    // ============ SELECTION & HIGHLIGHTS ============
    function selectUnit(unit) {
        if (gameState.selectedUnit) {
            gameState.selectedUnit.sprite.setStrokeStyle(3, gameState.selectedUnit.acted ? 0x888888 : 0xffffff);
        }
        gameState.selectedUnit = unit;
        if (unit) {
            unit.sprite.setStrokeStyle(4, 0xffff00);
            showMoveRange(unit);
            updateDetailPanel(unit);
        }
        updateUnitCards();
    }

    function clearHighlights() {
        gameState.highlightGraphics.clear();
    }

    function showMoveRange(unit) {
        clearHighlights();
        const moveRange = Math.floor(unit.ap * 2);
        const weapon = WEAPONS[unit.weaponId];

        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const cell = gameState.grid[y][x];
                const px = gameState.offsetX + x * TILE_SIZE;
                const py = gameState.offsetY + y * TILE_SIZE;

                // Show enemies in attack range
                if (cell.unit && cell.unit.team !== unit.team) {
                    const dist = Math.sqrt((x - unit.x)**2 + (y - unit.y)**2);
                    if (dist <= weapon.range) {
                        gameState.highlightGraphics.fillStyle(0xe74c3c, 0.4);
                        gameState.highlightGraphics.fillRect(px, py, TILE_SIZE - 1, TILE_SIZE - 1);
                    }
                    continue;
                }

                // Show walkable tiles
                if (!cell.walkable || cell.unit) continue;
                const path = findPath(unit.x, unit.y, x, y);
                if (path && path.length - 1 <= moveRange) {
                    gameState.highlightGraphics.fillStyle(0x3498db, 0.2);
                    gameState.highlightGraphics.fillRect(px, py, TILE_SIZE - 1, TILE_SIZE - 1);
                }
            }
        }
    }

    // ============ UI ============
    function createUnitCards() {
        const container = document.getElementById('unit-cards');
        container.innerHTML = '';

        // Blue Team Section
        const blueSection = document.createElement('div');
        blueSection.className = 'team-section';
        blueSection.innerHTML = '<div class="team-header blue">üîµ YOUR TEAM</div>';
        const blueUnits = document.createElement('div');
        blueUnits.className = 'team-units';
        gameState.units.filter(u => u.team === 'a').forEach(u => {
            blueUnits.appendChild(createUnitCard(u));
        });
        blueSection.appendChild(blueUnits);
        container.appendChild(blueSection);

        // Divider
        const divider = document.createElement('div');
        divider.className = 'team-divider';
        container.appendChild(divider);

        // Red Team Section
        const redSection = document.createElement('div');
        redSection.className = 'team-section';
        redSection.innerHTML = '<div class="team-header red">üî¥ ENEMY TEAM</div>';
        const redUnits = document.createElement('div');
        redUnits.className = 'team-units';
        gameState.units.filter(u => u.team === 'b').forEach(u => {
            redUnits.appendChild(createUnitCard(u));
        });
        redSection.appendChild(redUnits);
        container.appendChild(redSection);
    }

    function createUnitCard(unit) {
        const card = document.createElement('div');
        card.className = `unit-card ${unit.team === 'b' ? 'enemy' : ''} ${unit.acted ? 'acted' : ''} ${unit.hp <= 0 ? 'dead' : ''}`;
        card.id = `card-${unit.id}`;
        if (gameState.selectedUnit === unit) card.classList.add('selected');

        const weapon = WEAPONS[unit.weaponId];
        const hpPct = (unit.hp / unit.maxHp) * 100;
        const hpClass = hpPct > 60 ? '' : (hpPct > 30 ? 'wounded' : 'critical');

        let apDots = '';
        for (let i = 0; i < unit.maxAp; i++) {
            apDots += `<div class="ap-dot ${i < unit.ap ? 'filled' : ''}"></div>`;
        }

        // Status effect icons
        let effectIcons = '';
        unit.statusEffects.forEach(e => {
            const effect = STATUS_EFFECTS[e.id];
            effectIcons += `<span class="effect-icon" title="${effect.name} (${e.duration} turns)">${effect.emoji}</span>`;
        });

        card.innerHTML = `
            <div class="unit-card-header">
                <span class="unit-card-name team-${unit.team}" title="${unit.name}">${unit.origin.emoji} ${unit.codename}</span>
            </div>
            <div class="unit-card-hp"><div class="unit-card-hp-fill ${hpClass}" style="width: ${hpPct}%"></div></div>
            <div class="unit-card-stats">
                <span>‚ù§Ô∏è ${unit.hp}</span>
                <span title="${unit.personality.name}">${unit.personality.emoji}</span>
                <span title="${weapon.name}">${weapon.emoji}</span>
            </div>
            <div class="unit-card-ap">${apDots}</div>
            ${effectIcons ? `<div class="unit-card-effects">${effectIcons}</div>` : ''}
        `;

        card.onclick = () => {
            // Allow player to select their team's units
            if (unit.team === gameState.playerTeam && !unit.acted && gameState.currentTeam === gameState.playerTeam && !gameState.aiVsAi) {
                selectUnit(unit);
            }
        };

        return card;
    }

    function updateUnitCards() {
        gameState.units.forEach(u => {
            const card = document.getElementById(`card-${u.id}`);
            if (!card) return;

            card.className = `unit-card ${u.team === 'b' ? 'enemy' : ''} ${u.acted ? 'acted' : ''} ${u.hp <= 0 ? 'dead' : ''}`;
            if (gameState.selectedUnit === u) card.classList.add('selected');

            const hpPct = (u.hp / u.maxHp) * 100;
            const hpClass = hpPct > 60 ? '' : (hpPct > 30 ? 'wounded' : 'critical');
            card.querySelector('.unit-card-hp-fill').style.width = hpPct + '%';
            card.querySelector('.unit-card-hp-fill').className = `unit-card-hp-fill ${hpClass}`;
            card.querySelector('.unit-card-stats span').textContent = `‚ù§Ô∏è ${u.hp}/${u.maxHp}`;

            let apDots = '';
            for (let i = 0; i < u.maxAp; i++) {
                apDots += `<div class="ap-dot ${i < u.ap ? 'filled' : ''}"></div>`;
            }
            card.querySelector('.unit-card-ap').innerHTML = apDots;

            // Update effects
            let effectsContainer = card.querySelector('.unit-card-effects');
            if (!effectsContainer && u.statusEffects.length > 0) {
                effectsContainer = document.createElement('div');
                effectsContainer.className = 'unit-card-effects';
                card.appendChild(effectsContainer);
            }
            if (effectsContainer) {
                let effectIcons = '';
                u.statusEffects.forEach(e => {
                    const effect = STATUS_EFFECTS[e.id];
                    effectIcons += `<span class="effect-icon" title="${effect.name} (${e.duration} turns)">${effect.emoji}</span>`;
                });
                effectsContainer.innerHTML = effectIcons;
            }
        });
    }

    function updateDetailPanel(unit) {
        const panel = document.getElementById('selected-unit-detail');
        if (!unit) { panel.classList.add('hidden'); return; }

        panel.classList.remove('hidden');
        const weapon = WEAPONS[unit.weaponId];
        const armor = ARMORS[unit.armorId];
        const threatInfo = THREAT_LEVELS[unit.threatLevel];

        document.getElementById('detail-origin-emoji').textContent = unit.origin.emoji;
        document.getElementById('detail-name').textContent = unit.name;
        document.getElementById('detail-name').className = `detail-name team-${unit.team}`;
        document.getElementById('detail-subtitle').textContent = `${unit.origin.name} ‚Ä¢ ${threatInfo.emoji} ${threatInfo.name} ‚Ä¢ ${unit.personality.emoji} ${unit.personality.name}`;
        document.getElementById('detail-hp-fill').style.width = (unit.hp / unit.maxHp * 100) + '%';
        document.getElementById('detail-hp-text').textContent = `${unit.hp}/${unit.maxHp}`;
        document.getElementById('detail-weapon').textContent = `${weapon.emoji} ${weapon.name}`;
        document.getElementById('detail-damage').textContent = weapon.damage;
        document.getElementById('detail-range').textContent = weapon.range;
        document.getElementById('detail-armor').textContent = `${armor.emoji} ${armor.name} (DR ${armor.dr})`;
        document.getElementById('detail-str').textContent = unit.str;
        document.getElementById('detail-agl').textContent = unit.agl;

        // Status effects
        const effectsDiv = document.getElementById('detail-effects');
        effectsDiv.innerHTML = '';
        unit.statusEffects.forEach(e => {
            const effect = STATUS_EFFECTS[e.id];
            const badge = document.createElement('span');
            badge.className = 'detail-effect-badge';
            badge.innerHTML = `${effect.emoji} ${effect.name} (${e.duration})`;
            effectsDiv.appendChild(badge);
        });

        let apPips = '';
        for (let i = 0; i < unit.maxAp; i++) {
            apPips += `<div class="detail-ap-pip ${i < unit.ap ? 'filled' : ''}"></div>`;
        }
        document.getElementById('detail-ap-bar').innerHTML = apPips;
    }

    // Verbosity modes: 'verbose' = show everything, 'concise' = main actions only
    let logVerbosity = 'verbose';

    function toggleVerbosity() {
        const btn = document.getElementById('verbosity-toggle');
        if (logVerbosity === 'verbose') {
            logVerbosity = 'concise';
            btn.textContent = 'üìã CONCISE';
            btn.classList.add('concise');
        } else {
            logVerbosity = 'verbose';
            btn.textContent = 'üìù VERBOSE';
            btn.classList.remove('concise');
        }
    }

    function addLog(msg, type) {
        // In concise mode, skip detail lines (start with spaces) and system/effect messages
        if (logVerbosity === 'concise') {
            // Skip indented detail lines
            if (msg.startsWith('  ')) return;
            // Skip empty lines
            if (msg.trim() === '') return;
            // Skip system messages except turn/kill announcements
            if (type === 'system' && !msg.includes('Turn') && !msg.includes('‚îÄ')) return;
            // Skip effect detail messages
            if (type === 'effect' && !msg.includes('SURGE') && !msg.includes('bypasses')) return;
        }

        const log = document.getElementById('combat-log');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        entry.textContent = msg;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
    }

    // ============ AI vs AI MODE ============
    function toggleAiVsAi() {
        gameState.aiVsAi = !gameState.aiVsAi;
        const btn = document.getElementById('ai-vs-ai-btn');

        if (gameState.aiVsAi) {
            btn.classList.add('active');
            btn.textContent = '‚èπÔ∏è STOP';
            addLog('ü§ñ === AI vs AI MODE ACTIVATED ===', 'system');
            addLog('üéÆ Both teams are now AI-controlled!', 'ai');

            if (gameState.currentTeam === 'a' && !gameState.animating) {
                runBlueAI();
            }
        } else {
            btn.classList.remove('active');
            btn.textContent = 'ü§ñ AI vs AI';
            addLog('üéÆ === AI vs AI MODE DEACTIVATED ===', 'system');
        }
    }

    // ============ TEAM SELECTION ============
    function togglePlayerTeam() {
        if (gameState.aiVsAi) {
            addLog('‚ö†Ô∏è Cannot switch teams in AI vs AI mode!', 'system');
            return;
        }

        gameState.playerTeam = gameState.playerTeam === 'a' ? 'b' : 'a';
        const btn = document.getElementById('team-select-btn');

        if (gameState.playerTeam === 'a') {
            btn.textContent = 'üîµ Playing: BLUE';
            btn.style.background = '#1a4a7c';
            addLog('üîµ === NOW PLAYING AS BLUE TEAM ===', 'system');
        } else {
            btn.textContent = 'üî¥ Playing: RED';
            btn.style.background = '#7c1a1a';
            addLog('üî¥ === NOW PLAYING AS RED TEAM ===', 'system');
        }

        // Update turn controls if it's now AI's turn
        updateTurnControls();

        // If it's now the AI's turn, trigger AI
        if (gameState.currentTeam !== gameState.playerTeam && !gameState.animating) {
            setTimeout(() => {
                if (gameState.currentTeam === 'a') {
                    runBlueAI();
                } else {
                    runRedAI();
                }
            }, 500);
        }
    }

    function updateTurnControls() {
        const isPlayerTurn = gameState.currentTeam === gameState.playerTeam;
        document.getElementById('end-turn-btn').disabled = !isPlayerTurn || gameState.aiVsAi;
    }

    // ============ STATUS EFFECT PROCESSING ============
    function processStatusEffects(team) {
        gameState.units.filter(u => u.team === team && u.hp > 0).forEach(unit => {
            const toRemove = [];

            unit.statusEffects.forEach((effect, idx) => {
                const effectDef = STATUS_EFFECTS[effect.id];

                // Apply damage over time
                if (effectDef.damagePerTurn && effectDef.damagePerTurn > 0) {
                    unit.hp -= effectDef.damagePerTurn;
                    addLog(`${effectDef.emoji} ${unit.name} takes ${effectDef.damagePerTurn} ${effectDef.name.toLowerCase()} damage!`, 'damage');
                    updateUnitVisuals(unit);

                    if (unit.hp <= 0) {
                        const scene = game.scene.scenes[0];
                        killUnit(unit, scene, 'DOT');
                        addLog(`üíÄ ${unit.name} succumbs to ${effectDef.name.toLowerCase()}!`, 'kill');
                        checkVictory();
                    }
                }

                // Reduce duration
                effect.duration--;
                if (effect.duration <= 0) {
                    toRemove.push(idx);
                    addLog(`${effectDef.emoji} ${unit.name}'s ${effectDef.name.toLowerCase()} wears off.`, 'effect');
                }
            });

            // Remove expired effects
            toRemove.reverse().forEach(idx => unit.statusEffects.splice(idx, 1));
        });
        updateUnitCards();
    }

    // ============ TURN MANAGEMENT ============
    function endTurn() {
        if (gameState.animating) return;

        // Check for victory before proceeding
        const aAlive = gameState.units.filter(u => u.team === 'a' && u.hp > 0).length;
        const bAlive = gameState.units.filter(u => u.team === 'b' && u.hp > 0).length;
        if (aAlive === 0 || bAlive === 0) {
            gameState.aiVsAi = false;
            document.getElementById('ai-vs-ai-btn').classList.remove('active');
            document.getElementById('ai-vs-ai-btn').textContent = 'ü§ñ AI vs AI';
            return;
        }

        // Process status effects for ending team
        processStatusEffects(gameState.currentTeam);

        gameState.units.forEach(u => {
            if (u.team === gameState.currentTeam) {
                u.acted = false;
                // Apply AP penalties from status effects
                let apPenalty = 0;
                u.statusEffects.forEach(e => {
                    const effect = STATUS_EFFECTS[e.id];
                    if (effect.apPenalty) apPenalty += effect.apPenalty;
                });
                u.ap = Math.max(1, u.maxAp - apPenalty);
                u.sprite.setAlpha(1);
            }
        });

        gameState.currentTeam = gameState.currentTeam === 'a' ? 'b' : 'a';
        if (gameState.currentTeam === 'a') gameState.turn++;

        const teamName = gameState.currentTeam === 'a' ? 'üîµ BLUE TEAM' : 'üî¥ RED TEAM';
        const teamEmoji = gameState.currentTeam === 'a' ? 'üîµ' : 'üî¥';
        document.getElementById('turn-indicator').innerHTML = `Turn ${gameState.turn} - <span class="team-${gameState.currentTeam}">${teamName}</span>`;
        addLog(`--- ${teamEmoji} ${gameState.currentTeam === 'a' ? 'BLUE' : 'RED'} TEAM's Turn (Turn ${gameState.turn}) ---`, 'system');

        clearHighlights();
        clearPathPreview();
        gameState.selectedUnit = null;
        updateUnitCards();
        updateDetailPanel(null);

        // Check if it's player's turn or AI's turn
        const isPlayerTurn = gameState.currentTeam === gameState.playerTeam;

        if (isPlayerTurn && !gameState.aiVsAi) {
            // Player's turn - enable controls
            document.getElementById('end-turn-btn').disabled = false;
            const first = gameState.units.find(u => u.team === gameState.playerTeam && !u.acted && u.hp > 0);
            if (first) selectUnit(first);
        } else {
            // AI's turn - disable controls and run appropriate AI
            document.getElementById('end-turn-btn').disabled = true;
            if (gameState.currentTeam === 'a') {
                runBlueAI();
            } else {
                runEnemyAI(); // Red team AI
            }
        }
    }

    // Alias for consistency
    function runRedAI() { runEnemyAI(); }

    // ============ AI TARGET SELECTION BY PERSONALITY ============
    function selectTargetByPersonality(unit, targets) {
        if (targets.length === 0) return null;

        const personality = unit.personality;
        const targetPref = personality.targetPref;

        // Calculate threat scores for all targets
        const scoredTargets = targets.map(t => {
            const weapon = WEAPONS[t.weaponId];
            const hpPct = t.hp / t.maxHp;
            const threatScore = weapon.damage * (1 + (t.str / 100)) * (t.hp / 50);
            return {
                target: t,
                hp: t.hp,
                maxHp: t.maxHp,
                hpPct,
                threatScore,
                dist: Math.sqrt((t.x - unit.x)**2 + (t.y - unit.y)**2)
            };
        });

        let selected;

        switch (targetPref) {
            case 1: // Most HP - attack the strongest/healthiest
                scoredTargets.sort((a, b) => b.hp - a.hp);
                selected = scoredTargets[0];
                break;

            case 2: // Least HP - finish off the wounded
                scoredTargets.sort((a, b) => a.hp - b.hp);
                selected = scoredTargets[0];
                break;

            case 3: // Major Threat - attack highest threat score
                scoredTargets.sort((a, b) => b.threatScore - a.threatScore);
                selected = scoredTargets[0];
                break;

            case 4: // Minor Threat - attack lowest threat score
                scoredTargets.sort((a, b) => a.threatScore - b.threatScore);
                selected = scoredTargets[0];
                break;

            case 5: // Random
                selected = scoredTargets[Math.floor(Math.random() * scoredTargets.length)];
                break;

            default:
                selected = scoredTargets[0];
        }

        return selected.target;
    }

    // ============ BLUE TEAM AI ============
    function runBlueAI() {
        const scene = game.scene.scenes[0];
        const allies = gameState.units.filter(u => u.team === 'a' && u.hp > 0);
        addLog(`üîµ Blue AI controlling ${allies.length} units`, 'ai');
        let idx = 0;

        function next() {
            if (!gameState.aiVsAi) {
                addLog('üõë AI vs AI mode stopped', 'system');
                return;
            }

            if (idx >= allies.length) {
                setTimeout(endTurn, 500);
                return;
            }

            const ally = allies[idx];
            if (ally.hp <= 0) { idx++; next(); return; }

            // Check if stunned
            if (ally.statusEffects.some(e => STATUS_EFFECTS[e.id].skipTurn)) {
                addLog(`üí´ ${ally.name} is stunned and cannot act!`, 'ai');
                ally.acted = true;
                idx++;
                setTimeout(next, gameState.aiSpeed);
                return;
            }

            ally.sprite.setStrokeStyle(4, 0xffff00);
            addLog(`üîµ ${ally.personality.emoji} ${ally.name} (${ally.personality.name}) analyzing...`, 'ai');

            setTimeout(() => {
                runSingleAI(ally, 'b', scene, () => {
                    ally.sprite.setStrokeStyle(3, 0xffffff);
                    ally.acted = true;
                    ally.sprite.setAlpha(0.7);
                    updateUnitCards();
                    idx++;
                    setTimeout(next, gameState.aiSpeed);
                });
            }, gameState.aiSpeed);
        }
        next();
    }

    // ============ ENEMY AI (RED TEAM) ============
    function runEnemyAI() {
        const scene = game.scene.scenes[0];
        const enemies = gameState.units.filter(u => u.team === 'b' && u.hp > 0);
        addLog(`üî¥ Red AI controlling ${enemies.length} units`, 'ai');
        let idx = 0;

        function next() {
            if (idx >= enemies.length) {
                setTimeout(endTurn, 500);
                return;
            }

            const enemy = enemies[idx];
            if (enemy.hp <= 0) { idx++; next(); return; }

            // Check if stunned
            if (enemy.statusEffects.some(e => STATUS_EFFECTS[e.id].skipTurn)) {
                addLog(`üí´ ${enemy.name} is stunned and cannot act!`, 'ai');
                enemy.acted = true;
                idx++;
                setTimeout(next, gameState.aiSpeed);
                return;
            }

            enemy.sprite.setStrokeStyle(4, 0xffff00);
            addLog(`üî¥ ${enemy.personality.emoji} ${enemy.name} (${enemy.personality.name}) analyzing...`, 'ai');

            setTimeout(() => {
                runSingleAI(enemy, 'a', scene, () => {
                    enemy.sprite.setStrokeStyle(3, 0xffffff);
                    enemy.acted = true;
                    enemy.sprite.setAlpha(0.7);
                    updateUnitCards();
                    idx++;
                    setTimeout(next, gameState.aiSpeed);
                });
            }, gameState.aiSpeed);
        }
        next();
    }

    function runSingleAI(unit, targetTeam, scene, callback) {
        const allTargets = gameState.units.filter(u => u.team === targetTeam && u.hp > 0);
        if (allTargets.length === 0) {
            addLog(`  ‚ùå No targets found!`, 'ai');
            callback();
            return;
        }

        const weapon = WEAPONS[unit.weaponId];
        const teamEmoji = unit.team === 'a' ? 'üîµ' : 'üî¥';

        // Filter targets by Line of Sight (for ranged weapons)
        let targets = allTargets;
        if (weapon.range > 1) {
            const visibleTargets = allTargets.filter(t => hasLineOfSight(unit.x, unit.y, t.x, t.y));
            if (visibleTargets.length > 0) {
                targets = visibleTargets;
            } else {
                // No visible targets - AI will try to move to get LOS
                addLog(`  ${teamEmoji} ${unit.codename}: No targets in LOS - searching...`, 'ai');
            }
        }

        // Use personality-driven target selection
        const target = selectTargetByPersonality(unit, targets);

        if (!target) {
            addLog(`  ${teamEmoji} ${unit.name}: No valid target`, 'ai');
            callback();
            return;
        }

        const distToTarget = Math.sqrt((target.x - unit.x)**2 + (target.y - unit.y)**2);
        addLog(`  ${teamEmoji} ${unit.name} ‚Üí ${target.origin.emoji} ${target.name} (dist: ${distToTarget.toFixed(1)}, range: ${weapon.range})`, 'ai');

        // Attack if in range and have AP
        if (distToTarget <= weapon.range && unit.ap >= weapon.ap) {
            addLog(`  ${teamEmoji} üéØ IN RANGE - attacking!`, 'ai');
            attackUnitAI(unit, target, scene, () => {
                // Try to attack again if we still have AP
                if (unit.ap >= weapon.ap && target.hp > 0) {
                    const stillInRange = Math.sqrt((target.x - unit.x)**2 + (target.y - unit.y)**2) <= weapon.range;
                    if (stillInRange) {
                        addLog(`  ${teamEmoji} ${unit.name} attacking again (${unit.ap} AP left)`, 'ai');
                        setTimeout(() => attackUnitAI(unit, target, scene, callback), gameState.aiSpeed);
                    } else {
                        callback();
                    }
                } else {
                    callback();
                }
            });
            return;
        }

        // Out of range - need to move closer
        const moveRange = Math.floor(unit.ap * 2);
        addLog(`  ${teamEmoji} üèÉ OUT OF RANGE - move range: ${moveRange} tiles`, 'ai');

        // AI style affects movement
        const aiStyle = unit.personality.aiStyle;
        let best = null;
        let bestScore = Infinity;

        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const cell = gameState.grid[y][x];
                if (!cell.walkable || cell.unit) continue;

                const path = findPath(unit.x, unit.y, x, y);
                if (!path) continue;

                const pathLength = path.length - 1;
                if (pathLength > moveRange) continue;

                const distFromTargetAfterMove = Math.sqrt((x - target.x)**2 + (y - target.y)**2);

                let score;
                if (aiStyle === 'rush') {
                    // Rush: Get as close as possible
                    score = distFromTargetAfterMove;
                } else if (aiStyle === 'defensive') {
                    // Defensive: Stay at max range if possible
                    if (distFromTargetAfterMove <= weapon.range) {
                        score = -(distFromTargetAfterMove); // Prefer farther within range
                    } else {
                        score = distFromTargetAfterMove + 10;
                    }
                } else if (aiStyle === 'ranged') {
                    // Ranged: Stay at optimal range (70-100% of max range)
                    const optimalRange = weapon.range * 0.8;
                    score = Math.abs(distFromTargetAfterMove - optimalRange);
                    if (distFromTargetAfterMove > weapon.range) score += 20;
                } else {
                    // Balanced: Get into range efficiently
                    if (distFromTargetAfterMove <= weapon.range) {
                        score = pathLength * 0.5;
                    } else {
                        score = distFromTargetAfterMove + 10;
                    }
                }

                // Bonus for cover tiles
                if (cell.cover > 0) score -= 3;

                if (score < bestScore) {
                    bestScore = score;
                    best = { x, y, path, pathLength, distFromTarget: distFromTargetAfterMove };
                }
            }
        }

        if (best) {
            const moveCost = Math.ceil(best.pathLength / 2);
            addLog(`  ${teamEmoji} ${unit.name} moving ${best.pathLength} tiles (${moveCost} AP) toward ${target.name}`, 'ai');

            moveUnit(unit, best.x, best.y, best.path, moveCost, scene, () => {
                const newDist = Math.sqrt((target.x - unit.x)**2 + (target.y - unit.y)**2);
                addLog(`  ${teamEmoji} ${unit.name} now at distance ${newDist.toFixed(1)}`, 'ai');

                if (newDist <= weapon.range && unit.ap >= weapon.ap && target.hp > 0) {
                    addLog(`  ${teamEmoji} üéØ NOW IN RANGE - attacking!`, 'ai');
                    setTimeout(() => attackUnitAI(unit, target, scene, callback), gameState.aiSpeed);
                } else {
                    addLog(`  ${teamEmoji} ${unit.name} turn complete (${unit.ap} AP left)`, 'ai');
                    callback();
                }
            });
        } else {
            addLog(`  ${teamEmoji} ${unit.name} CANNOT MOVE - no valid path found`, 'ai');
            callback();
        }
    }

    function attackUnitAI(attacker, defender, scene, callback) {
        const weapon = WEAPONS[attacker.weaponId];
        if (attacker.ap < weapon.ap || defender.hp <= 0) {
            callback();
            return;
        }

        // Check Line of Sight (melee always has LOS)
        if (weapon.range > 1) {
            const losCheck = checkLOS(attacker, defender);
            if (losCheck.blocked) {
                addLog(`üîá ${attacker.codename} can't see ${defender.codename} - ${losCheck.reason} blocking!`, 'ai');
                callback();
                return;
            }
        }

        attacker.ap -= weapon.ap;
        gameState.animating = true;

        // Emit sound from attack location
        emitSound(attacker.x, attacker.y, weapon.sound, attacker.name, attacker.team);

        // Track shots
        gameState.combatStats.shotsFired[attacker.team]++;
        if (!gameState.combatStats.damageByUnit[attacker.name]) {
            gameState.combatStats.damageByUnit[attacker.name] = { dealt: 0, taken: 0, kills: 0, shots: 0, hits: 0, meleeDamage: 0, rangedDamage: 0, rangedShots: 0, rangedHits: 0, team: attacker.team };
        }
        if (!gameState.combatStats.damageByUnit[defender.name]) {
            gameState.combatStats.damageByUnit[defender.name] = { dealt: 0, taken: 0, kills: 0, shots: 0, hits: 0, meleeDamage: 0, rangedDamage: 0, rangedShots: 0, rangedHits: 0, team: defender.team };
        }
        gameState.combatStats.damageByUnit[attacker.name].shots++;
        const isMeleeAI = weapon.range <= 1;
        if (!isMeleeAI) {
            gameState.combatStats.damageByUnit[attacker.name].rangedShots++;
        }

        fireVisualEffect(scene, attacker, defender, weapon, () => {
            const result = resolveAttack(attacker, defender);
            const verbs = DAMAGE_VERBS[weapon.damageType] || DAMAGE_VERBS.GUNFIRE;
            const ctx = result.context;

            if (result.hit) {
                defender.hp -= result.damage;
                const overkill = defender.hp < 0 ? Math.abs(defender.hp) : 0;
                updateUnitVisuals(defender);

                // Track comprehensive stats
                gameState.combatStats.totalDamageDealt[attacker.team] += result.damage;
                gameState.combatStats.armorAbsorbed[defender.team] += result.dr;
                gameState.combatStats.damageByUnit[attacker.name].dealt += result.damage;
                gameState.combatStats.damageByUnit[attacker.name].hits++;
                gameState.combatStats.damageByUnit[defender.name].taken += result.damage;

                // Track melee vs ranged damage
                if (isMeleeAI) {
                    gameState.combatStats.meleeDamage[attacker.team] += result.damage;
                    gameState.combatStats.damageByUnit[attacker.name].meleeDamage += result.damage;
                } else {
                    gameState.combatStats.rangedDamage[attacker.team] += result.damage;
                    gameState.combatStats.damageByUnit[attacker.name].rangedDamage += result.damage;
                    gameState.combatStats.damageByUnit[attacker.name].rangedHits++;
                }

                // Track most damage taken
                if (gameState.combatStats.damageByUnit[defender.name].taken > gameState.combatStats.mostDamageTaken.damage) {
                    gameState.combatStats.mostDamageTaken = { unit: defender.name, damage: gameState.combatStats.damageByUnit[defender.name].taken };
                }

                // Track by weapon
                if (!gameState.combatStats.damageByWeapon[attacker.weaponId]) {
                    gameState.combatStats.damageByWeapon[attacker.weaponId] = { damage: 0, shots: 0, hits: 0, kills: 0 };
                }
                gameState.combatStats.damageByWeapon[attacker.weaponId].damage += result.damage;
                gameState.combatStats.damageByWeapon[attacker.weaponId].hits++;

                // Track by result type
                if (result.result === 'CRIT') gameState.combatStats.criticalHits[attacker.team]++;
                else if (result.result === 'GRAZE') gameState.combatStats.grazes[attacker.team]++;
                else gameState.combatStats.hits[attacker.team]++;

                // Track overkill
                if (overkill > 0) {
                    gameState.combatStats.overkillDamage[attacker.team] += overkill;
                }

                // ========== RICH COMBAT FEEDBACK ==========
                const verb = result.result === 'CRIT' ? verbs.crit : (result.result === 'GRAZE' ? verbs.graze : verbs.hit);

                let attackLine = `${weapon.emoji} ${attacker.name} ${verb} ${defender.origin.emoji} ${defender.name}`;
                if (result.result === 'CRIT') attackLine += ' üí•üí•';
                addLog(attackLine, 'attack');

                // Roll breakdown
                let rollInfo = `  üé≤ Roll: ${ctx.roll}`;
                if (ctx.agilityBonus !== 0) rollInfo += ` ${ctx.agilityBonus >= 0 ? '+' : ''}${ctx.agilityBonus} AGL`;
                if (ctx.weaponAccuracy !== 0) rollInfo += ` ${ctx.weaponAccuracy >= 0 ? '+' : ''}${ctx.weaponAccuracy} ACC`;
                if (ctx.closeRangeBonus > 0) rollInfo += ` +${ctx.closeRangeBonus} CLOSE`;
                if (ctx.coverBonus > 0) rollInfo += ` -${ctx.coverBonus} COVER`;
                rollInfo += ` = ${ctx.finalRoll}`;
                addLog(rollInfo, 'system');

                // Damage breakdown
                let damageDetail = `  üí• ${result.damage} damage`;
                if (result.strBonus > 0) damageDetail += ` (+${result.strBonus} STR)`;
                if (result.mult === 1.5) damageDetail += ' [√ó1.5 CRIT]';
                else if (result.mult === 0.5) damageDetail += ' [√ó0.5 GRAZE]';
                addLog(damageDetail, 'damage');

                // Armor feedback
                if (result.dr > 0) {
                    if (ctx.energyBypass) {
                        addLog(`  ‚ö° Energy bypasses ${ctx.armorName}! (${result.dr} DR)`, 'effect');
                    } else if (ctx.armorPierced) {
                        addLog(`  üî© AP rounds punch through ${ctx.armorName}!`, 'effect');
                    } else {
                        addLog(`  üõ°Ô∏è ${ctx.armorName} absorbs ${result.dr} damage`, 'system');
                    }
                }

                // EMP bonus
                if (result.empBonus > 0) {
                    addLog(`  ‚ö° EMP SURGE! +${result.empBonus} vs ${defender.origin.name}!`, 'effect');
                }

                // Overkill
                if (overkill > 0 && defender.hp <= 0) {
                    if (overkill > 30) {
                        addLog(`  üíÄ OBLITERATED! (${overkill} overkill)`, 'kill');
                    } else if (overkill > 15) {
                        addLog(`  üíÄ DEVASTATING! (${overkill} overkill)`, 'kill');
                    } else {
                        addLog(`  üíÄ Overkill: ${overkill}`, 'damage');
                    }
                }

                // Apply status effects
                applyStatusEffect(attacker, defender, weapon, result);

                // Check for injury
                if (result.result === 'CRIT' || overkill > 0) {
                    const injury = rollInjury(defender, result.result === 'CRIT', overkill);
                    if (injury && injury.severity !== 'LUCKY' && injury.severity !== 'LIGHT') {
                        addLog(`  ü©π INJURY: ${injury.description}`, 'injury');
                        gameState.combatStats.injuriesInflicted.push({
                            victim: defender.name,
                            injury: injury.description,
                            attacker: attacker.name,
                            turn: gameState.turn
                        });
                    }
                }

                // Apply knockback if weapon has it and defender is still alive
                if (weapon.knockback && defender.hp > 0) {
                    applyKnockback(attacker, defender, weapon.knockback, scene);
                }

                if (defender.hp <= 0) {
                    // Track kill stats
                    gameState.combatStats.totalKills[attacker.team]++;
                    gameState.combatStats.damageByUnit[attacker.name].kills++;
                    if (!gameState.combatStats.damageByWeapon[attacker.weaponId]) {
                        gameState.combatStats.damageByWeapon[attacker.weaponId] = { damage: 0, shots: 0, hits: 0, kills: 0 };
                    }
                    gameState.combatStats.damageByWeapon[attacker.weaponId].kills++;

                    // Kill streak
                    if (!gameState.combatStats.currentStreaks[attacker.name]) {
                        gameState.combatStats.currentStreaks[attacker.name] = 0;
                    }
                    gameState.combatStats.currentStreaks[attacker.name]++;
                    if (gameState.combatStats.currentStreaks[attacker.name] > gameState.combatStats.longestKillstreak.streak) {
                        gameState.combatStats.longestKillstreak = {
                            unit: attacker.name,
                            streak: gameState.combatStats.currentStreaks[attacker.name]
                        };
                    }

                    // Log the kill
                    const killEntryAI = {
                        turn: gameState.turn,
                        killer: attacker.name,
                        killerOrigin: attacker.origin.emoji,
                        killerTeam: attacker.team,
                        victim: defender.name,
                        victimOrigin: defender.origin.emoji,
                        victimTeam: defender.team,
                        weapon: weapon.name,
                        overkill: overkill
                    };
                    gameState.combatStats.killLog.push(killEntryAI);

                    // Track first blood
                    if (!gameState.combatStats.firstBlood) {
                        gameState.combatStats.firstBlood = killEntryAI;
                    }
                    // Always update last kill
                    gameState.combatStats.lastKill = killEntryAI;

                    gameState.combatStats.turnDeaths.push({
                        turn: gameState.turn,
                        unit: defender.name,
                        team: defender.team
                    });

                    killUnit(defender, scene, weapon.damageType);
                    checkVictory();
                } else {
                    addLog(`  ‚ù§Ô∏è ${defender.name}: ${defender.hp}/${defender.maxHp} HP remaining`, 'ai');
                }
            } else {
                // ========== MISS FEEDBACK ==========
                gameState.combatStats.misses[attacker.team]++;

                if (result.context && result.context.coverSaved) {
                    addLog(`${weapon.emoji} ${attacker.name} fires at ${defender.name}...`, 'attack');
                    addLog(`  ü™® COVER SAVES! Shot blocked by cover!`, 'effect');
                    addLog(`  üé≤ Roll: ${result.context.roll} - ${result.context.coverBonus} cover = ${result.context.finalRoll}`, 'system');
                } else {
                    addLog(`${weapon.emoji} ${attacker.name} ${verbs.miss} ${defender.name}!`, 'attack');
                    if (result.context) {
                        addLog(`  üé≤ Roll: ${result.context.roll} ‚Üí ${result.context.finalRoll} (needed 40+)`, 'system');
                    }
                }
            }
            gameState.animating = false;
            updateUnitCards();
            callback();
        });
    }

    function checkVictory() {
        const aAlive = gameState.units.filter(u => u.team === 'a' && u.hp > 0).length;
        const bAlive = gameState.units.filter(u => u.team === 'b' && u.hp > 0).length;

        if (aAlive === 0 || bAlive === 0) {
            gameState.gameOver = true;
            gameState.animating = true;
            gameState.aiVsAi = false;

            // Disable all buttons
            document.getElementById('ai-vs-ai-btn').classList.remove('active');
            document.getElementById('ai-vs-ai-btn').disabled = true;
            document.getElementById('end-turn-btn').disabled = true;

            const winningTeam = bAlive === 0 ? 'a' : 'b';
            gameState.winningTeam = winningTeam; // Store for button access
            const winnerName = winningTeam === 'a' ? 'BLUE TEAM' : 'RED TEAM';
            const winnerEmoji = winningTeam === 'a' ? 'üîµ' : 'üî¥';
            const winnerColor = winningTeam === 'a' ? '#3498db' : '#e74c3c';

            // Show victory overlay
            showVictoryOverlay(winnerName, winnerEmoji, winnerColor);
        }
    }

    function showVictoryOverlay(winnerName, emoji, color) {
        // Create overlay
        const overlay = document.createElement('div');
        overlay.id = 'victory-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.5s ease;
        `;

        overlay.innerHTML = `
            <div style="font-size: 80px; animation: bounce 0.5s ease;">${emoji}</div>
            <div style="font-size: 48px; font-weight: bold; color: ${color}; margin: 20px 0; text-shadow: 0 0 30px ${color};">
                ${winnerName} VICTORIOUS!
            </div>
            <div style="font-size: 24px; color: #888;">Combat complete in ${gameState.turn} turns</div>
            <button onclick="document.getElementById('victory-overlay').remove(); showPostCombatReport(gameState.winningTeam);" style="
                margin-top: 30px;
                padding: 15px 40px;
                font-size: 18px;
                background: ${color};
                border: none;
                border-radius: 8px;
                color: white;
                cursor: pointer;
                font-weight: bold;
            ">VIEW BATTLE REPORT</button>
            <button onclick="location.reload()" style="
                margin-top: 15px;
                padding: 12px 30px;
                font-size: 14px;
                background: #333;
                border: 2px solid #555;
                border-radius: 8px;
                color: white;
                cursor: pointer;
            ">üîÑ NEW BATTLE</button>
        `;

        // Add animation keyframes
        if (!document.getElementById('victory-animations')) {
            const style = document.createElement('style');
            style.id = 'victory-animations';
            style.textContent = `
                @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                @keyframes bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
            `;
            document.head.appendChild(style);
        }

        document.body.appendChild(overlay);
    }

    function showPostCombatReport(winningTeam) {
        const stats = gameState.combatStats;
        const winner = winningTeam === 'a' ? 'BLUE' : 'RED';
        const winnerEmoji = winningTeam === 'a' ? 'üîµ' : 'üî¥';
        const loser = winningTeam === 'a' ? 'RED' : 'BLUE';
        const loserEmoji = winningTeam === 'a' ? 'üî¥' : 'üîµ';

        // Clear log and show report
        const log = document.getElementById('combat-log');
        log.innerHTML = '';

        // ===== HEADER =====
        addLog('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó', 'kill');
        addLog(`‚ïë  ${winnerEmoji} ${winner} TEAM VICTORIOUS! ${winnerEmoji}  ‚ïë`, 'kill');
        addLog('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù', 'kill');
        addLog('', 'system');

        // ===== BATTLE SUMMARY =====
        addLog('üìä ENGAGEMENT SUMMARY', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
        addLog(`‚è±Ô∏è Duration: ${gameState.turn} turns`, 'system');
        addLog(`üíÄ Total Casualties: ${stats.killLog.length}`, 'system');
        addLog(`üî´ Total Shots Fired: ${stats.shotsFired.a + stats.shotsFired.b}`, 'system');
        addLog(`üí• Total Damage Dealt: ${stats.totalDamageDealt.a + stats.totalDamageDealt.b}`, 'system');
        addLog('', 'system');

        // ===== FIRST & LAST BLOOD =====
        if (stats.firstBlood) {
            const fb = stats.firstBlood;
            const fbTeam = fb.killerTeam === 'a' ? 'üîµ' : 'üî¥';
            addLog(`ü©∏ FIRST BLOOD: ${fbTeam} ${fb.killer} ‚Üí ${fb.victim} (Turn ${fb.turn})`, 'kill');
        }
        if (stats.lastKill && stats.killLog.length > 1) {
            const lk = stats.lastKill;
            const lkTeam = lk.killerTeam === 'a' ? 'üîµ' : 'üî¥';
            addLog(`‚ö∞Ô∏è FINAL BLOW: ${lkTeam} ${lk.killer} ‚Üí ${lk.victim} (Turn ${lk.turn})`, 'kill');
        }
        addLog('', 'system');

        // ===== TEAM COMPARISON =====
        addLog('‚öîÔ∏è TEAM BREAKDOWN', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');

        const blueAccuracy = stats.shotsFired.a > 0 ? Math.round((stats.hits.a + stats.grazes.a + stats.criticalHits.a) / stats.shotsFired.a * 100) : 0;
        const redAccuracy = stats.shotsFired.b > 0 ? Math.round((stats.hits.b + stats.grazes.b + stats.criticalHits.b) / stats.shotsFired.b * 100) : 0;

        addLog(`üîµ BLUE TEAM`, 'move');
        addLog(`   üí• Total Damage: ${stats.totalDamageDealt.a} (üî´ ${stats.rangedDamage.a} ranged | üëä ${stats.meleeDamage.a} melee)`, 'system');
        addLog(`   üíÄ Kills: ${stats.totalKills.a}`, 'system');
        addLog(`   üéØ Accuracy: ${blueAccuracy}% (${stats.shotsFired.a} shots)`, 'system');
        addLog(`   üìà Breakdown: ${stats.criticalHits.a} crits | ${stats.hits.a} hits | ${stats.grazes.a} grazes | ${stats.misses.a} miss`, 'system');
        addLog(`   üõ°Ô∏è Damage Blocked by Armor: ${stats.armorAbsorbed.a}`, 'system');
        if (stats.overkillDamage.a > 0) addLog(`   ‚ò†Ô∏è Overkill Damage: ${stats.overkillDamage.a}`, 'damage');
        addLog('', 'system');

        addLog(`üî¥ RED TEAM`, 'attack');
        addLog(`   üí• Total Damage: ${stats.totalDamageDealt.b} (üî´ ${stats.rangedDamage.b} ranged | üëä ${stats.meleeDamage.b} melee)`, 'system');
        addLog(`   üíÄ Kills: ${stats.totalKills.b}`, 'system');
        addLog(`   üéØ Accuracy: ${redAccuracy}% (${stats.shotsFired.b} shots)`, 'system');
        addLog(`   üìà Breakdown: ${stats.criticalHits.b} crits | ${stats.hits.b} hits | ${stats.grazes.b} grazes | ${stats.misses.b} miss`, 'system');
        addLog(`   üõ°Ô∏è Damage Blocked by Armor: ${stats.armorAbsorbed.b}`, 'system');
        if (stats.overkillDamage.b > 0) addLog(`   ‚ò†Ô∏è Overkill Damage: ${stats.overkillDamage.b}`, 'damage');
        addLog('', 'system');

        // ===== COMBAT COMMENDATIONS =====
        addLog('üèÜ COMBAT COMMENDATIONS', 'effect');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');

        // Find MVP (most damage dealt)
        let mvp = null;
        let mvpDamage = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.dealt > mvpDamage) {
                mvpDamage = data.dealt;
                mvp = name;
            }
        }
        if (mvp) {
            const mvpData = stats.damageByUnit[mvp];
            const mvpTeam = mvpData.team === 'a' ? 'üîµ' : 'üî¥';
            const efficiency = mvpData.shots > 0 ? Math.round(mvpData.hits / mvpData.shots * 100) : 0;
            addLog(`ü•á MOST VALUABLE: ${mvpTeam} ${mvp}`, 'effect');
            addLog(`   ${mvpData.dealt} dmg | ${mvpData.kills} kills | ${efficiency}% accuracy`, 'system');
        }

        // The Reaper - Most Kills
        let reaper = null;
        let reaperKills = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.kills > reaperKills) {
                reaperKills = data.kills;
                reaper = name;
            }
        }
        if (reaper && (reaper !== mvp || reaperKills > 1)) {
            const reaperData = stats.damageByUnit[reaper];
            const reaperTeam = reaperData.team === 'a' ? 'üîµ' : 'üî¥';
            addLog(`üíÄ THE REAPER: ${reaperTeam} ${reaper} (${reaperKills} kills)`, 'kill');
        }

        // Deadeye - Best ranged accuracy (min 2 ranged shots)
        let deadeye = null;
        let deadeyeAcc = 0;
        let deadeyeTeam = '';
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.rangedShots >= 2) {
                const acc = data.rangedHits / data.rangedShots;
                if (acc > deadeyeAcc) {
                    deadeyeAcc = acc;
                    deadeye = name;
                    deadeyeTeam = data.team;
                }
            }
        }
        if (deadeye) {
            const teamEmoji = deadeyeTeam === 'a' ? 'üîµ' : 'üî¥';
            addLog(`üéØ DEADEYE: ${teamEmoji} ${deadeye} (${Math.round(deadeyeAcc * 100)}% ranged accuracy)`, 'move');
        }

        // Blue Deadeye (best accuracy on Blue team)
        let blueDeadeye = null;
        let blueDeadeyeAcc = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.team === 'a' && data.rangedShots >= 2) {
                const acc = data.rangedHits / data.rangedShots;
                if (acc > blueDeadeyeAcc) {
                    blueDeadeyeAcc = acc;
                    blueDeadeye = name;
                }
            }
        }
        if (blueDeadeye && blueDeadeye !== deadeye) {
            addLog(`üîµ BLUE MARKSMAN: ${blueDeadeye} (${Math.round(blueDeadeyeAcc * 100)}% ranged)`, 'move');
        }

        // Red Deadeye (best accuracy on Red team)
        let redDeadeye = null;
        let redDeadeyeAcc = 0;
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.team === 'b' && data.rangedShots >= 2) {
                const acc = data.rangedHits / data.rangedShots;
                if (acc > redDeadeyeAcc) {
                    redDeadeyeAcc = acc;
                    redDeadeye = name;
                }
            }
        }
        if (redDeadeye && redDeadeye !== deadeye) {
            addLog(`üî¥ RED MARKSMAN: ${redDeadeye} (${Math.round(redDeadeyeAcc * 100)}% ranged)`, 'attack');
        }

        // The Brawler - Most melee damage
        let brawler = null;
        let brawlerDmg = 0;
        let brawlerTeam = '';
        for (const [name, data] of Object.entries(stats.damageByUnit)) {
            if (data.meleeDamage > brawlerDmg) {
                brawlerDmg = data.meleeDamage;
                brawler = name;
                brawlerTeam = data.team;
            }
        }
        if (brawler && brawlerDmg > 0) {
            const teamEmoji = brawlerTeam === 'a' ? 'üîµ' : 'üî¥';
            addLog(`üëä THE BRAWLER: ${teamEmoji} ${brawler} (${brawlerDmg} melee damage)`, 'attack');
        }

        // The Tank - Most damage taken (and survived or died heroically)
        if (stats.mostDamageTaken.unit) {
            const tankData = stats.damageByUnit[stats.mostDamageTaken.unit];
            const tankTeam = tankData ? (tankData.team === 'a' ? 'üîµ' : 'üî¥') : '‚ùì';
            addLog(`üõ°Ô∏è THE TANK: ${tankTeam} ${stats.mostDamageTaken.unit} (absorbed ${stats.mostDamageTaken.damage} damage)`, 'system');
        }

        // The Executioner - Most overkill damage
        let executioner = null;
        let execOverkill = 0;
        for (const kill of stats.killLog) {
            if (kill.overkill > execOverkill) {
                execOverkill = kill.overkill;
                executioner = kill.killer;
            }
        }
        if (executioner && execOverkill > 10) {
            addLog(`‚ò†Ô∏è THE EXECUTIONER: ${executioner} (${execOverkill} max overkill)`, 'kill');
        }

        // Kill Streak
        if (stats.longestKillstreak.streak > 1) {
            addLog(`üî• KILLING SPREE: ${stats.longestKillstreak.unit} (${stats.longestKillstreak.streak} consecutive kills)`, 'kill');
        }

        // Cover Hero
        if (stats.coverSaves > 0) {
            addLog(`ü™® COVER SAVED: ${stats.coverSaves} shots blocked by cover!`, 'effect');
        }

        addLog('', 'system');

        // ===== WEAPON EFFECTIVENESS =====
        addLog('üî´ ARSENAL REPORT', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');

        const weaponEntries = Object.entries(stats.damageByWeapon).sort((a, b) => b[1].damage - a[1].damage);
        for (const [weaponId, data] of weaponEntries) {
            const weapon = WEAPONS[weaponId];
            if (weapon && data.damage > 0) {
                const avgDmg = data.hits > 0 ? Math.round(data.damage / data.hits) : 0;
                addLog(`${weapon.emoji} ${weapon.name}: ${data.damage} total (${avgDmg} avg) | ${data.kills} kills`, 'system');
            }
        }
        addLog('', 'system');

        // ===== KILL TIMELINE =====
        addLog('‚ö∞Ô∏è CASUALTY REPORT', 'injury');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');

        for (const kill of stats.killLog) {
            const killerTeam = kill.killerTeam === 'a' ? 'üîµ' : 'üî¥';
            const victimTeam = kill.victimTeam === 'a' ? 'üîµ' : 'üî¥';

            // Get kill verb based on overkill damage
            let killVerb = 'killed';
            if (kill.overkill > 30) killVerb = 'OBLITERATED';
            else if (kill.overkill > 20) killVerb = 'DEVASTATED';
            else if (kill.overkill > 10) killVerb = 'DESTROYED';
            else if (kill.overkill > 5) killVerb = 'eliminated';

            let killLine = `T${kill.turn}: ${killerTeam} ${kill.killer} ${killVerb} ${victimTeam} ${kill.victim}`;
            if (kill.weapon) killLine += ` [${kill.weapon}]`;
            if (kill.overkill > 0) killLine += ` (+${kill.overkill})`;
            addLog(killLine, 'kill');
        }
        addLog('', 'system');

        // ===== INJURIES =====
        if (stats.injuriesInflicted.length > 0) {
            addLog('ü©π INJURY REPORT', 'injury');
            addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');
            for (const inj of stats.injuriesInflicted) {
                addLog(`T${inj.turn}: ${inj.victim} - ${inj.injury}`, 'injury');
            }
            addLog('', 'system');
        }

        // ===== COMBATANT PERFORMANCE =====
        addLog('üë§ COMBATANT PERFORMANCE', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');

        const unitEntries = Object.entries(stats.damageByUnit).sort((a, b) => b[1].dealt - a[1].dealt);
        for (const [name, data] of unitEntries) {
            const teamEmoji = data.team === 'a' ? 'üîµ' : 'üî¥';
            const efficiency = data.shots > 0 ? Math.round(data.hits / data.shots * 100) : 0;
            const rangedAcc = data.rangedShots > 0 ? Math.round(data.rangedHits / data.rangedShots * 100) : 0;
            addLog(`${teamEmoji} ${name}:`, 'system');

            let statLine = `   ‚öîÔ∏è ${data.dealt} dealt`;
            if (data.rangedDamage > 0 && data.meleeDamage > 0) {
                statLine += ` (üî´${data.rangedDamage} + üëä${data.meleeDamage})`;
            } else if (data.meleeDamage > 0) {
                statLine += ` (üëä melee)`;
            }
            statLine += ` | üõ°Ô∏è ${data.taken} taken`;
            addLog(statLine, 'system');

            let statLine2 = `   üíÄ ${data.kills} kills | üéØ ${efficiency}% overall`;
            if (data.rangedShots > 0) {
                statLine2 += ` | üî´ ${rangedAcc}% ranged`;
            }
            addLog(statLine2, 'system');
        }
        addLog('', 'system');

        // ===== BATTLE ANALYSIS =====
        addLog('üìã BATTLE ANALYSIS', 'system');
        addLog('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ', 'system');

        const totalShots = stats.shotsFired.a + stats.shotsFired.b;
        const avgAccuracy = totalShots > 0 ? Math.round((stats.hits.a + stats.hits.b + stats.grazes.a + stats.grazes.b + stats.criticalHits.a + stats.criticalHits.b) / totalShots * 100) : 0;
        const critRate = totalShots > 0 ? Math.round((stats.criticalHits.a + stats.criticalHits.b) / totalShots * 100) : 0;
        const totalOverkill = stats.overkillDamage.a + stats.overkillDamage.b;

        // Speed of battle
        if (gameState.turn <= 3) {
            addLog('‚ö° BLITZ - Lightning-fast engagement. Decisive action!', 'effect');
        } else if (gameState.turn <= 5) {
            addLog('üéØ EFFICIENT - Clean tactical execution.', 'effect');
        } else if (gameState.turn >= 8) {
            addLog('‚è≥ PROLONGED - A grinding war of attrition.', 'effect');
        }

        // Accuracy assessment
        if (avgAccuracy >= 70) {
            addLog('üéØ PRECISION COMBAT - Outstanding marksmanship ('+avgAccuracy+'%)', 'effect');
        } else if (avgAccuracy >= 50) {
            addLog('‚öîÔ∏è STANDARD ENGAGEMENT - Average accuracy ('+avgAccuracy+'%)', 'system');
        } else {
            addLog('üí® CHAOTIC FIREFIGHT - Poor accuracy overall ('+avgAccuracy+'%)', 'system');
        }

        // Critical hits
        if (critRate >= 15) {
            addLog('üí• HIGH-IMPACT - Devastating critical hit rate ('+critRate+'%)', 'effect');
        }

        // Overkill
        if (totalOverkill > 50) {
            addLog('‚ò†Ô∏è BRUTAL - Excessive force deployed (+'+totalOverkill+' overkill)', 'kill');
        } else if (totalOverkill > 20) {
            addLog('üí™ OVERWHELMING FORCE - Significant overkill damage', 'damage');
        }

        // Cover
        if (stats.coverSaves >= 3) {
            addLog('ü™® TACTICAL POSITIONING - Cover played a major role', 'effect');
        }

        // Close fight
        const dmgDiff = Math.abs(stats.totalDamageDealt.a - stats.totalDamageDealt.b);
        const totalDmg = stats.totalDamageDealt.a + stats.totalDamageDealt.b;
        if (totalDmg > 0 && dmgDiff / totalDmg < 0.2) {
            addLog('‚öñÔ∏è CLOSE FIGHT - Both sides dealt similar damage', 'system');
        }

        addLog('', 'system');
        addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'system');
        addLog('üíæ Career stats recorded!', 'effect');
        addLog('üìä Click CAREERS button to view history', 'system');
        addLog('üîÑ Refresh page to battle again!', 'system');

        // Record career stats
        recordCareerStats(winningTeam);
    }

    // ============ START ============
    game = new Phaser.Game(config);
    </script>
</body>
</html>
